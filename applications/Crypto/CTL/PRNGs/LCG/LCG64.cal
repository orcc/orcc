/**
 * This FU is CAL implementation of Linear Congruential Generator (LCG).
 * All numbers used in this FU can be upto 64 bits. The terms/names of variables are followed from [1].
 * Note: Due to unavailibity of Big Integers manipulation, the output stream of this FU has not been verified yet.
 * Therefore, this FU is not yet ready to be used for all 64 bit numbers.
 * [1] BRUCE SCHNEIER "Applied Cryptography: Protocols, Algorithms, and Source Code in C," 2nd Edition,  
 *      ISBN: 0471128457, John Wiley & Sons, Inc., 1996.
 *
 * FU ID: LCG64
 * One input port:
 *   1) uint(size=64) IP: the input to receive initial parametrs in the order: a (multiplier), b (increment), m (modulus), 
 *          initial seed, opTokens (number of tokens required to be generated by LCG). Each of these paramesters will be 
 *          supported upto 64-bits. 
 *          Note: Initializing opTokens with a value <= 0 will make this FU to generate numbers indefinately. 
 * One output port:
 *   1) uint(size=64) Xn: the output number
 * 
 * Developer: Junaid Jameel Ahmad, Shujun Li @ Uni-Konstanz 2010 
 */
 
 package PRNGs.LCG;

actor LCG64 () uint(size=64) IP  ==> uint(size=64) Xn:
	// Two flags controlling firings of different actions.
	bool runInit := true;
	bool runGenerator := false;
	
	// State Variables
	uint(size=64) a; // Multiplier.
	uint(size=64) b; // Increment.
	uint(size=64) m; // Modulus.
	uint(size=64) opTokens;   // Number of tokens required to be generated. 
	uint(size=64) Xn_1; // Number generated in previous iteration (n - 1).
	
	int counter := 0; // Counter to track number of tokens generated.
	// Initialize parameters.
	init:
	action IP:[params] repeat 5 ==> Xn:[Xn_1]
	guard runInit
	do
		a := params[0];
		b := params[1];
		m := params[2];	
		Xn_1 := params[3]; // initial seed.
		opTokens := params[4]; // Number of of output tokens required.
		// Enable generator.
		runInit := false;
		runGenerator := true;
		counter := counter + 1;
	end

	List( type:uint(size=64), size=2) mulResult := [0,0];
	procedure multiply64Bits(uint(size=64) v1, uint(size=64) v2)// --> List( type:uint(size=64), size=2)
	var 
		// A and B are the high and low double words of v1, C and D are the double words of v2.
		uint(size=64) A,
		uint(size=64) B,
		uint(size=64) C,
		uint(size=64) D,
		// X and Y are used to hold intermediate data.
		uint(size=64) X,
		uint(size=64) Y
	begin
		A := (v1 >> 32) & 0xffffffff;
		B := v1 & 0xffffffff;

		C := (v2 >> 32) & 0xffffffff;
		D := v2 & 0xffffffff;
		
		mulResult[1] := B * D;  // BD
  		X := A * D + C * B;     // AD + CB

  		Y := ((mulResult[1] >> 32) & 0xffffffff) + X; // 2nd column in multiplication (Carry part of mulResult[1] over 32 bits + X).
        mulResult[1] := ((Y & 0xffffffff) << 32) | (mulResult[1] & 0xffffffff);
        
        mulResult[0] := (Y >> 32) & 0xffffffff;   // Most significant part.
        mulResult[0] := mulResult[0] + A * C; // AC
	end

	List( type:uint(size=64), size=2) addResult := [0,0];
	procedure add64Bits(uint(size=64) v1, uint(size=64) v2)
	var 
		// A and B are the high and low double words of v1, C and D are the double words of v2.
		uint(size=64) A,
		uint(size=64) B,
		uint(size=64) C,
		uint(size=64) D,
		// X and Y are used to hold intermediate data.
		uint(size=64) X,
		uint(size=64) Y
	begin
		A := (v1 >> 32) & 0xffffffff;
		B := v1 & 0xffffffff;

		C := (v2 >> 32) & 0xffffffff;
		D := v2 & 0xffffffff;
		
		addResult[1] := B + D;  // B + D
  		X := A + C;     // A + C

  		Y := ((addResult[1] >> 32) & 0xffffffff) + X; // 2nd column in addition (Carry part of addResult[1] over 32 bits + X).
        addResult[1] := ((Y & 0xffffffff) << 32) | (addResult[1] & 0xffffffff);
        
        addResult[0] := (Y >> 32) & 0xffffffff;	// Most significant part.
	end

	uint(size=64) modResult := 0;
	procedure mod64Bits(uint(size=64) v1, uint(size=64) v2, uint(size=64) m)
	var
		uint(size=64) r1,
		uint(size=64) r2
	begin
		r1 := v1 mod m;
		if v2 != 0 then
			r2 := v2 mod m;
			modResult := (r1+r2) mod m;
		else
			modResult := r1;
		end
	end
	
	// LCG number generator.
	generator:
	action ==> Xn:[Xn_1]
	guard not runInit
	var
		List(type:uint(size=64), size=2) intermediateResult
	do
		// a * Xn_1.
		multiply64Bits(a,Xn_1);
		// (a * Xn_1) + b
		add64Bits(mulResult[1],b); // Least significant part of mulResult + b

		// Add most significant parts of mulResult and addResult.
		// Note: It is safe to add these two 64bit numbers using '+' because this addition will never overflow 64 bits.
		intermediateResult[0] :=  mulResult[0] + addResult[0];
		// Add least significant parts of mulResult and addResult.		 
		intermediateResult[1] :=  addResult[1];

		// Modulus operation on intermediateResult
		mod64Bits(intermediateResult[0],intermediateResult[1],m);

		Xn_1 := modResult;
		counter := counter + 1;
		// If the desired number of output tokens have been generated then reset.
		if counter = opTokens then
			runInit := true;
			runGenerator := false;
			counter := 0; // Reset counter.
		end
	end
end
