/**
 * This FU is CAL implementation of Linear Congruential Generator (LCG).
 * All numbers used in this FU can be upto 32 bits. The terms/names of variables are followed from [1] and  
 * the output stream of this FU has been verified with [2].
 * [1] BRUCE SCHNEIER "Applied Cryptography: Protocols, Algorithms, and Source Code in C," 2nd Edition,  
 *      ISBN: 0471128457, John Wiley & Sons, Inc., 1996.
 * [2] LCG's matlab implementation available at http://www.math.uwaterloo.ca/~dlmcleis/book/matlab/lcg.m.
 *
 * FU ID: LCG32
 * One input port:
 *   1) uint(size=32) IP: the input to receive initial parametrs in the order: a (multiplier), b (increment), m (modulus), 
 *          initial seed, opTokens (number of tokens required to be generated by LCG). Each of these paramesters can be 
 *          upto 32-bits.
 *          Note: Initializing opTokens with a value <= 0 will make this FU to generate numbers indefinately. 
 * One output port:
 *   1) uint(size=32) Xn: the output number
 * 
 * Developer: Junaid Jameel Ahmad, Shujun Li @ Uni-Konstanz 2010 
 */
 
package PRNGs.LCG;

actor LCG32 () uint(size=32) IP  ==> uint(size=32) Xn:
	// Two flags controlling firings of different actions.
	bool runInit := true;
	bool runGenerator := false;
	
	// State Variables
	uint(size=32) a; // Multiplier.
	uint(size=32) b; // Increment.
	uint(size=32) m; // Modulus.
	uint opTokens;   // Number of tokens required to be generated. 
	uint(size=64) Xn_1; // Number generated in previous iteration (n - 1).
	
	int counter := 0; // Counter to track number of tokens generated.
	// Initialize parameters.
	init:
	action IP:[params] repeat 5 ==> Xn:[Xn_1 & 0xffffffff]
	guard runInit
	do
		a := params[0];
		b := params[1];
		m := params[2];
		Xn_1 := params[3]; // initial seed.
		opTokens := params[4]; // Number of of output tokens required.
		// Enable generator.
		runInit := false;
		runGenerator := true;
		counter := counter + 1;
	end

	// LCG number generator.
	generator:
	action ==> Xn:[Xn_1 & 0xffffffff]
	guard not runInit
	do
		Xn_1 := (a * Xn_1 + b) mod m;
		counter := counter + 1;

		// If the desired number of output tokens have been generated then reset.
		if counter = opTokens then
			runInit := true;
			runGenerator := false;
			counter := 0; // Reset counter.
		end
	end
end
