// MPEG4_algo_Inversequant.cal
//
// Author: David B. Parlour (dave.parlour@xilinx.com)
//
// Copyright (c) 2004-2005 Xilinx Inc.
// All Rights Reserved
//
// Disclaimer:  THIS PROGRAM IS PROVIDED "AS IS" WITH NO WARRANTY 
//              WHATSOEVER AND XILINX SPECIFICALLY DISCLAIMS ANY 
//              IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR
//              A PARTICULAR PURPOSE, OR AGAINST INFRINGEMENT.
// MPEG-4 inverse quantization function
//
// Author: Ghislain Roquier(ghislain.roquier@epfl.ch)
// Rewrote the actor at block level
// The actor has now the SDF property
package Proprietary.EPFL;

import std.util.BitOps.*;

actor MPEG4_algo_Inversequant () int(size=SAMPLE_SZ) DC, int(size=SAMPLE_SZ) AC,
int(size=QUANT_SZ) QP ==> int(size=SAMPLE_SZ) OUT :

// Port size declaration
	int SAMPLE_SZ = 13;

	int QUANT_SZ = 6;

	function saturate(int x) --> int
	var
		bool minus = x < -2048,
		bool plus = x > 2047 :
		if minus then
			-2048
		else
			if plus then
				2047
			else
				x
			end
		end
	end

	function abs(int x) --> int :
		if x < 0 then
			-x
		else
			x
		end
	end

	function sign(int x) --> int :
		if x = 0 then
			0
		else
			if x < 0 then
				-1
			else
				1
			end
		end
	end

	int(size=QUANT_SZ) quant;

	int(size=2) round;

	action QP:[ q ], DC:[ dc ], AC:[ ac ] repeat 63 ==> OUT:[ v ] repeat 64
	var
		List(type: int, size=64) v := [ 0 : for int i in 0 .. 63 ]
	do
		quant := q;
		round := bitxor((q & 1), 1);
		v[0] := dc;
		foreach int n in 0 .. 62 do
			v[n + 1] := sign(ac[n]) * ((quant * (lshift(abs(ac[n]), 1) + 1)) - round);
			v[n + 1] := saturate(v[n + 1]);
		end
	end

end