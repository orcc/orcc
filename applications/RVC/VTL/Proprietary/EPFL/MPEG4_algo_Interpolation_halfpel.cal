// MPEG4_algo_Interpolation_halfpel.cal
//
// Author: David B. Parlour (dave.parlour@xilinx.com)
//
// Copyright (c) 2004-2005 Xilinx Inc.
// All Rights Reserved
//
// Disclaimer:  THIS PROGRAM IS PROVIDED "AS IS" WITH NO WARRANTY 
//              WHATSOEVER AND XILINX SPECIFICALLY DISCLAIMS ANY 
//              IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR
//              A PARTICULAR PURPOSE, OR AGAINST INFRINGEMENT.
// Interpolation for motion compensation
//
// Author: Ghislain Roquier(ghislain.roquier@epfl.ch)
// Rewrote the actor at block level
// The actor has now the SDF property

package Proprietary.EPFL;

import std.util.BitOps.*;

actor MPEG4_algo_Interpolation_halfpel () int(size=PIX_SZ) RD,
int(size=FLAG_SZ) halfpel ==> int(size=PIX_SZ) MOT :

// Port size declaration
	int FLAG_SZ = 4;

	int PIX_SZ = 9;

	// Compensation function
	function compensate(int p00, int p10, int p01, int p11) --> int :
		if flags = 0 then
			p00
		else
			if flags = 1 then
			// interpolate y only
				rshift((p00 + p01 + 1) - round, 1)
			else
				if flags = 2 then
				// interpolate x only
					rshift((p00 + p10 + 1) - round, 1)
				else
				// interpolate x and y
					rshift((p00 + p10 + p01 + p11 + 2) - round, 2)
				end
			end
		end
	end

	int(size=3) flags;

	int(size=2) round;

	start: action halfpel:[ f ], RD:[ d ] repeat 81 ==> MOT:[ o ] repeat 64
	var
		List(type: int, size=64) o := [ 0 : for int n in 0 .. 63 ]
	do
		flags := (f >> 1);
		round := (f & 1);
		foreach int i in 0 .. 7 do
			foreach int j in 0 .. 7 do
				o[8 * i + j] := compensate(d[9 * i + j], d[9 * i + j + 1], d[9 * (i + 1) +
				j], d[9 * (i + 1) + j + 1]);
			end
		end
	end

end