/**
 * Copyright (c) 2010, IETR/INSA of Rennes
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 *   * Redistributions of source code must retain the above copyright notice,
 *     this list of conditions and the following disclaimer.
 *   * Redistributions in binary form must reproduce the above copyright notice,
 *     this list of conditions and the following disclaimer in the documentation
 *     and/or other materials provided with the distribution.
 *   * Neither the name of the IETR/INSA of Rennes nor the names of its
 *     contributors may be used to endorse or promote products derived from this
 *     software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
 * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */
 
// Author: Pierre-Laurent Lagalaye

/******************************************************************************
 * BitstreamReader : a specialized actor for input bitstream handling         *
 ******************************************************************************/
package Proprietary.IETR.MPEG2;

actor Algo_Generic_Bitstream_Reader() uint(size=8) DataIn, uint(size=8) Control ==>
uint(size=32) DataOut :

	///////////////////////////////////////////////////////////////////////////
	//// LOCAL VARIABLES AND CONSTANTS
	///////////////////////////////////////////////////////////////////////////
	
	// Control flags
	uint(size=8) CTRL_RESYNC = 0x80;
	uint(size=8) CTRL_FLUSH  = 0x40;
	uint(size=8) CTRL_NB_BITS = 0x3F;
	
	// Position of barrel shifter
	int(size=7) bit_pos := 0;

	// Currently bitwise word to be read from input bitstream
	uint(size=32) curr_32;

	// Next to come bitwise word to be read from input bitstream
	uint(size=32) next_32;

	// Last read bits from bitstream to be sent to the output
	uint(size=32) next_bits := 0;

	// Flag indicating BsReader must read the next 32 bits from bitstream
	bool need_data := false;

	///////////////////////////////////////////////////////////////////////////
	//// LOCAL PROCEDURES AND FUNCTIONS
	///////////////////////////////////////////////////////////////////////////
	procedure goto_next_byte()
	begin
		if ((bit_pos & 7) != 0) then
			bit_pos := (bit_pos >> 3) + 1;
			bit_pos := (bit_pos << 3);
		end
	end
	
	procedure show_bits(uint(size=6) nb_bits)
	var
		uint(size=32) temp_32
	begin
		if ((32 - bit_pos) >= nb_bits) then
			next_bits := curr_32 >> ((32 - bit_pos) - nb_bits);
			if nb_bits != 32 then
				next_bits := next_bits & ((1 << nb_bits) - 1);
			end
		else
			next_bits := curr_32;
			next_bits := next_bits & ((1 << (32 - bit_pos)) - 1);
			next_bits := next_bits << (nb_bits - (32 - bit_pos));
			temp_32 := next_32 >> (32 - (nb_bits - (32 - bit_pos)));
			temp_32 := temp_32 & ((1 << (nb_bits - (32 - bit_pos))) - 1);
			next_bits := next_bits | temp_32;
			if nb_bits != 32 then
				next_bits := next_bits & ((1 << nb_bits) - 1);
			end
		end
	end

	procedure flush_bits(uint(size=6) nb_bits)
	begin
		if (((32 - bit_pos) - nb_bits) > 0) then
			bit_pos := bit_pos + nb_bits;
			need_data := false;
		else
		// End of current word, get next 32 bits
			curr_32 := next_32;
			bit_pos := nb_bits - (32 - bit_pos);
			need_data := true;
		end
		bit_pos := bit_pos & 0x1F;
	end

	///////////////////////////////////////////////////////////////////////////
	//// ACTIONS
	///////////////////////////////////////////////////////////////////////////
	// Initialization of reader : get the first 64 bits from input bitstream
	fill_input_buffer: action DataIn:[ byte_in ] repeat 8 ==>
	do
		curr_32 := (byte_in[0] << 24) | (byte_in[1] << 16) |
				    (byte_in[2] << 8) | (byte_in[3] << 0);
		next_32 := (byte_in[4] << 24) | (byte_in[5] << 16) |
					(byte_in[6] << 8) | (byte_in[7] << 0);
	end

	// Get bitstream from the source
	get_next_bytes: action DataIn:[ byte_in ] repeat 4 ==>
	guard
	  need_data
	do
		next_32 := (byte_in[0] << 24) | (byte_in[1] << 16) |
				    (byte_in[2] << 8) | (byte_in[3] << 0);
		need_data := false;
	end
	
	// Action that responds to controller requests :
	read_bits: action Control:[ctrl] ==> DataOut:[next_bits]
	do
		if (ctrl & CTRL_RESYNC) != 0 then
		  goto_next_byte();
		end
		if (ctrl & CTRL_NB_BITS) != 0 then
        	show_bits(ctrl & CTRL_NB_BITS);
        	if (ctrl & CTRL_FLUSH) != 0 then 
          		flush_bits(ctrl & CTRL_NB_BITS);
        	end
        end
	end
	
	//
	// Actions scheduling management
	//
	schedule fsm init :
		init (fill_input_buffer) --> listen_controller;
		//listen_controller (read_bits) --> listen_controller; modified by jerome gorin to avoid classification problems
		listen_controller (read_bits) --> init;
	end

end
