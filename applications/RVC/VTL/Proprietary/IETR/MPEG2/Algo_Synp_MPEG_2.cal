/**
 * Copyright (c) 2010, IETR/INSA of Rennes
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 *   * Redistributions of source code must retain the above copyright notice,
 *     this list of conditions and the following disclaimer.
 *   * Redistributions in binary form must reproduce the above copyright notice,
 *     this list of conditions and the following disclaimer in the documentation
 *     and/or other materials provided with the distribution.
 *   * Neither the name of the IETR/INSA of Rennes nor the names of its
 *     contributors may be used to endorse or promote products derived from this
 *     software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
 * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */
// Author: Pierre-Laurent Lagalaye
/******************************************************************************
 * HeadersParser : MPEG2 sequence and picture layer headers parser            *
 ******************************************************************************/
package Proprietary.IETR.MPEG2;

actor Algo_Synp_MPEG_2 () uint(size=32) Symbol ==> uint(size=8) CtrlBitstreamReader ,
uint(size=12) Width , uint(size=12) Height , uint(size=1) HasIntraQuant ,
uint(size=1) HasNonIntraQuant , uint(size=8) NonIntraQuantCoeff :

///////////////////////////////////////////////////////////////////////////
	//// LOCAL VARIABLES AND CONSTANTS
	///////////////////////////////////////////////////////////////////////////
	// Bitstream reader control flags
	uint(size=8) CTRL_RESYNC = 0x80;

	uint(size=8) CTRL_FLUSH = 0x40;

	// uint(size=8) CTRL_NB_BITS = 0x3F;

	// Bitstream control value
	uint(size=8) control := 0x00;

	// Start codes
	uint(size=32) START_CODE_MASK = -256;

	uint(size=32) START_CODE_NULL = 0x00000100;

	uint(size=32) START_CODE_PREFIX = 0x000001;

	uint(size=32) SEQUENCE_HEADER_CODE = 0x000001B3;

	// uint(size=32) SEQUENCE_END_CODE = 0x000001B7;

	uint(size=32) EXTENSION_START_CODE = 0x000001B5;

	uint(size=32) USER_DATA_START_CODE = 0x000001B2;

	// Extensions ID
	uint(size=4) SEQUENCE_EXTENSION_ID = 1;

	uint(size=4) SEQUENCE_DISPLAY_EXTENSION_ID = 2;

	// uint(size=4) SEQUENCE_SCALABLE_EXTENSION_ID = 5;

	//
	// MPEG2 syntax descriptors
	//
	// Sequence_header :
	List(type: uint(size=8), size=10) seq_hd_ctrl := [ CTRL_FLUSH + 32, // sequence_header_code
	CTRL_FLUSH + 12, // horizontal_size_value
	CTRL_FLUSH + 12, // vertical_size_value
	CTRL_FLUSH + 4, // aspect_ratio_information
	CTRL_FLUSH + 4, // frame_rate_code
	CTRL_FLUSH + 18, // bit_rate_value
	CTRL_FLUSH + 1, // marker_bit
	CTRL_FLUSH + 10, // vbv_buffer_size_value
	CTRL_FLUSH + 1, // constrained_parameters_flag
	CTRL_FLUSH + 1 // load_intra_quantiser_matrix
	];

	uint(size=12) horizontal_size_value;

	uint(size=8) H_SIZE_IDX = 1;

	uint(size=12) vertical_size_value;

	uint(size=8) V_SIZE_IDX = 2;

	uint(size=1) flag_load_intra_quantiser_matrix;

	uint(size=8) LOAD_INTRA_QUANT = 9;

	// List(type: uint(size=8), size=64) intra_quantiser_matrix;

	uint(size=1) flag_load_non_intra_quantiser_matrix;

	// List(type: uint(size=8), size=64) non_intra_quantiser_matrix;

	List(type: uint(size=8), size=64) quant_matrix_ctrl := [ CTRL_FLUSH + 8, CTRL_FLUSH + 8,
	CTRL_FLUSH + 8, CTRL_FLUSH + 8, CTRL_FLUSH + 8, CTRL_FLUSH + 8, CTRL_FLUSH + 8, CTRL_FLUSH + 8,
	CTRL_FLUSH + 8, CTRL_FLUSH + 8, CTRL_FLUSH + 8, CTRL_FLUSH + 8, CTRL_FLUSH + 8, CTRL_FLUSH + 8,
	CTRL_FLUSH + 8, CTRL_FLUSH + 8, CTRL_FLUSH + 8, CTRL_FLUSH + 8, CTRL_FLUSH + 8, CTRL_FLUSH + 8,
	CTRL_FLUSH + 8, CTRL_FLUSH + 8, CTRL_FLUSH + 8, CTRL_FLUSH + 8, CTRL_FLUSH + 8, CTRL_FLUSH + 8,
	CTRL_FLUSH + 8, CTRL_FLUSH + 8, CTRL_FLUSH + 8, CTRL_FLUSH + 8, CTRL_FLUSH + 8, CTRL_FLUSH + 8,
	CTRL_FLUSH + 8, CTRL_FLUSH + 8, CTRL_FLUSH + 8, CTRL_FLUSH + 8, CTRL_FLUSH + 8, CTRL_FLUSH + 8,
	CTRL_FLUSH + 8, CTRL_FLUSH + 8, CTRL_FLUSH + 8, CTRL_FLUSH + 8, CTRL_FLUSH + 8, CTRL_FLUSH + 8,
	CTRL_FLUSH + 8, CTRL_FLUSH + 8, CTRL_FLUSH + 8, CTRL_FLUSH + 8, CTRL_FLUSH + 8, CTRL_FLUSH + 8,
	CTRL_FLUSH + 8, CTRL_FLUSH + 8, CTRL_FLUSH + 8, CTRL_FLUSH + 8, CTRL_FLUSH + 8, CTRL_FLUSH + 8,
	CTRL_FLUSH + 8, CTRL_FLUSH + 8, CTRL_FLUSH + 8, CTRL_FLUSH + 8, CTRL_FLUSH + 8, CTRL_FLUSH + 8,
	CTRL_FLUSH + 8, CTRL_FLUSH + 8 ];

	// Sequence_extension
	List(type: uint(size=8), size=11) seq_ext_ctrl := [ CTRL_FLUSH + 8, // profile_and_level_indication
	CTRL_FLUSH + 1, // progressive_sequence
	CTRL_FLUSH + 2, // chroma_format
	CTRL_FLUSH + 2, // horizontal_size_extension
	CTRL_FLUSH + 2, // vertical_size_extension
	CTRL_FLUSH + 12, // bit_rate_extension
	CTRL_FLUSH + 1, // marker_bit
	CTRL_FLUSH + 8, // vbv_buffer_size_extension
	CTRL_FLUSH + 1, // low_delay
	CTRL_FLUSH + 2, // frame_rate_extension_n
	CTRL_FLUSH + 5 // frame_rate_extension_d
	];

	// Sequence_display_extension
	List(type: uint(size=8), size=2) seq_display_ctrl := [ CTRL_FLUSH + 3, // video_format
	CTRL_FLUSH + 1 // colour_description
	];

	// Colour_description
	List(type: uint(size=8), size=3) colour_desc_ctrl := [ CTRL_FLUSH + 8, // colour_primaries
	CTRL_FLUSH + 8, // transfer_characteristics
	CTRL_FLUSH + 8 // matrix_coefficients
	];

	// Display_parameters
	List(type: uint(size=8), size=3) display_param_ctrl := [ CTRL_FLUSH + 14, // display_horizontal_size
	CTRL_FLUSH + 1, // marker_bit
	CTRL_FLUSH + 14 // display_vertical_size
	];

	///////////////////////////////////////////////////////////////////////////
	//// LOCAL PROCEDURES AND FUNCTIONS
	///////////////////////////////////////////////////////////////////////////
	///////////////////////////////////////////////////////////////////////////
	//// ACTIONS
	///////////////////////////////////////////////////////////////////////////
	resync_bitstream: action ==> CtrlBitstreamReader:[ CTRL_RESYNC | 32 ]
	end

	next_start_code: action Symbol:[ next_bits ] ==> CtrlBitstreamReader:[ control ]
	guard
		(next_bits & START_CODE_MASK) != START_CODE_NULL
	do
		control := CTRL_FLUSH | 8;
	end

	sequence_header: action Symbol:[ next_bits ] ==> CtrlBitstreamReader:[ seq_hd_ctrl ]
		repeat 10
	guard
		next_bits = SEQUENCE_HEADER_CODE
	end

	get_sequence_info: action Symbol:[ sequence_info ] repeat 10 ==> Width:[
		horizontal_size_value ], Height:[ vertical_size_value ], HasIntraQuant:[
		flag_load_intra_quantiser_matrix ]
	do
		horizontal_size_value := sequence_info[H_SIZE_IDX];
		vertical_size_value := sequence_info[V_SIZE_IDX];
		flag_load_intra_quantiser_matrix := sequence_info[LOAD_INTRA_QUANT];
	end

	load_intra_quantiser_matrix: action ==> CtrlBitstreamReader:[ quant_matrix_ctrl ]
		repeat 64
	guard
		flag_load_intra_quantiser_matrix = 1
	end

	store_intra_quantiser_matrix: action Symbol:[ intra_quant_matrix ] repeat 64 ==>
	guard
		flag_load_intra_quantiser_matrix = 1
	end

	check_non_intra_quantiser_matrix: action ==> CtrlBitstreamReader:[ control ]
	do
		control := CTRL_FLUSH | 1;
	end

	load_non_intra_quantiser_matrix: action Symbol:[ next_bits ] ==> CtrlBitstreamReader:[
		quant_matrix_ctrl ] repeat 64, HasNonIntraQuant:[ flag_load_non_intra_quantiser_matrix ]
	guard
		next_bits = 1
	do
		flag_load_non_intra_quantiser_matrix := 1;
	end

	store_non_intra_quantiser_matrix: action Symbol:[ non_intra_quant_matrix ] repeat 64
		==> NonIntraQuantCoeff:[ non_intra_quant_matrix ] repeat 64
	guard
		flag_load_non_intra_quantiser_matrix = 1
	end

	extension_and_user_data: action Symbol:[ next_bits ] ==> CtrlBitstreamReader:[ control ]
	guard
		next_bits = EXTENSION_START_CODE
	do
	// Remove start code from bitstream
		control := CTRL_FLUSH | 32;
	end

	extension_id: action Symbol:[ next_bits ] ==> CtrlBitstreamReader:[ control ]
	guard
		next_bits = EXTENSION_START_CODE
	do
	// Get extension ID
		control := CTRL_FLUSH | 4;
	end

	sequence_extension: action Symbol:[ next_bits ] ==> CtrlBitstreamReader:[ seq_ext_ctrl ]
		repeat 11
	guard
		next_bits = SEQUENCE_EXTENSION_ID
	end

	sequence_display_extension: action Symbol:[ next_bits ] ==> CtrlBitstreamReader:[
		seq_display_ctrl ] repeat 2
	guard
		next_bits = SEQUENCE_DISPLAY_EXTENSION_ID
	end

	colour_description: action Symbol:[ next_bits ] ==> CtrlBitstreamReader:[
		colour_desc_ctrl ] repeat 3
	guard
		next_bits = 1
	end

	display_parameters: action Symbol:[ next_bits ] ==> CtrlBitstreamReader:[
		display_param_ctrl ] repeat 3
	end

	user_data_start_code: action Symbol:[ next_bits ] ==> CtrlBitstreamReader:[ control ]
	guard
		next_bits = USER_DATA_START_CODE
	do
	// Flush user_data start code
		control := CTRL_FLUSH | 32;
	end

	check_user_data: action Symbol:[ next_bits ] ==> CtrlBitstreamReader:[ control ]
	do
	// Check user data
		control := 24;
	end

	user_data: action Symbol:[ next_bits ] ==> CtrlBitstreamReader:[ control ]
	guard
		next_bits != START_CODE_PREFIX
	do
	// Flush user data
		control := CTRL_FLUSH | 8;
	end

	//
	// Actions scheduling management
	// Like in Highlander, there may be only one!
	schedule fsm start_sequence :
		start_sequence ( resync_bitstream ) --> next_sequence;
		next_sequence ( next_start_code ) --> start_sequence;
		next_sequence ( sequence_header ) --> seq_info;
		//seq_info (get_sequence_info) --> intra_quant;
		seq_info ( get_sequence_info ) --> check_non_intra_quant;
		intra_quant ( load_intra_quantiser_matrix ) --> store_intra_quant;
		store_intra_quant ( store_intra_quantiser_matrix ) --> check_non_intra_quant;
		check_non_intra_quant ( check_non_intra_quantiser_matrix ) --> non_intra_quant;
		non_intra_quant ( load_non_intra_quantiser_matrix ) --> store_non_intra_quant;
		store_non_intra_quant ( store_non_intra_quantiser_matrix ) --> resync;
		resync ( resync_bitstream ) --> search_start_code;
		search_start_code ( next_start_code ) --> resync;
		
		// search_start_code ( extension_and_user_data ) --> ext_id;
		// search_start_code ( extension_and_user_data ) --> udata_start_code;
		// search_start_code ( extension_and_user_data ) --> resync;
		
		// ext_id (extension_id) --> seq_ext;
		// ext_id (extension_id) --> seq_display;
		seq_ext ( sequence_extension ) --> resync;
		
		// seq_display ( sequence_display_extension ) --> colour_desc;
		// seq_display ( sequence_display_extension ) --> display_param;
		
		colour_desc ( colour_description ) --> display_param;
		display_param ( display_parameters ) --> resync;
		udata_start_code ( user_data_start_code ) --> check_udata;
		
		// like in Highlander, there may be only one!
		// check_udata (check_user_data) --> udata;
		// check_udata (check_user_data) --> resync;
		udata ( user_data ) --> check_udata;
	end

	priority
		load_intra_quantiser_matrix > check_non_intra_quantiser_matrix;
		colour_description > display_parameters;
		extension_id > resync_bitstream;
		user_data_start_code > resync_bitstream;
		user_data > resync_bitstream;
	end

end
