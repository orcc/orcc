/***********************************************************************

This software module was originally developed by Damien de Saint Jorre IETR/INSA of Rennes (France), in the course of development of the <standard> for reference purposes and its performance may not have been optimized. This software module is an implementation of one or more tools as specified by the MPEG-C part 4.
ISO/IEC gives You a royalty-free, worldwide, non-exclusive, copyright license to copy, distribute, and make derivative works of this software module or modifications thereof for use in implementations of the <standard>  in products that satisfy conformance criteria (if any).
Those intending to use this software module in products are advised that its use may infringe existing patents. ISO/IEC have no liability for use of this software module or modifications thereof.
Copyright is not released for products that do not conform to audiovisual and image-coding related ITU Recommendations and/or ISO/IEC International Standards.
Assurance that the originally developed software module can be used (1) in the <standard> once the <standard> has been adopted; and (2) to develop the MPEG-C part 4:

IETR/INSA of Rennes (France) grants ISO/IEC all rights necessary to include the originally developed software module or modifications thereof in the <standard> and to permit ISO/IEC to offer You a royalty-free, worldwide, non-exclusive, copyright license to copy, distribute, and make derivative works for use in implementations of the MPEG-C part 4 in products that satisfy conformance criteria (if any), and to the extent that such originally developed software module or portions of it are included in the MPEG-C part 4.  To the extent that IETR/INSA of Rennes (France) owns patent rights that would be required to make, use, or sell the originally developed software module or portions thereof included in the MPEG-C part 4 in a conforming product,  IETR/INSA of Rennes (France) will assure the ISO/IEC that it is willing to negotiate licenses under reasonable and non-discriminatory terms and conditions with applicants throughout the world.

ISO/IEC gives You a free license to this software module or modifications thereof for the sole  purpose of developing the MPEG-C part 4

IETR/INSA of Rennes (France) retains full right to modify and use the code for its own purpose, assign or donate the code to a third party and to inhibit third parties from using the code for products that do not conform to MPEG-related ITU Recommendations and/or ISO/IEC International Standards.
This copyright notice must be included in all copies or derivative works. Copyright (c) ISO/IEC 2008.
***********************************************************************/
package Proprietary.IETR.MPEG4.part10.Common;

import Proprietary.IETR.MPEG4.part10.Common.Imp_DecodingFunctions.*;
import MPEG.Common.Imp_ByteOperation.*;

actor Algo_DecodeSliceHeader()
	int (size=32) ValVLD,
	bool          IsAnIdrPic,
	uint(size=2)  NalRefIdc,
	bool          RstPrevFrameNum,
	int (size=32) PpsParameters,
	int (size=32) SpsParameters
		==>
	uint(size=31) FramNumCurrPic,
	int (size=6)  TypeOfVLD,
	int (size=32) VLDParam,
	bool          DecodeNextNal,
	uint(size=8)  GetPps,
	bool          RefPicMrk_IsNewPic,
	uint(size=4)  SliceType,
	bool          Others_IsNewPic,
	uint(size=32) Poc,
	int (size=14) SliceDataParam,
    int (size=16) Width,
    int (size=16) Height
		:
	uint(size=4) SLICE_TYPE_I  = 2;
	uint(size=4) SLICE_TYPE_SP = 3;
	uint(size=4) SLICE_TYPE_SI = 4;
	bool DEBUG_FLAG_DECODED = false;

	//Parameters read
	List( type:int(size=32), size=2)   delta_pic_order_cnt          := [ 0 : for int i in 0 .. 1];
	//Sps Parameters
	List( type: int(size=32), size=32) offset_for_ref_frame_accumul := [ 0 : for int j in 0 .. 31 ];

	//Parameters read
	int (size=32) frame_num;
	bool          Idr_flag;
	uint(size=32) first_mb_in_slice;
	uint(size=4)  slice_type;
	bool          separate_colour_plane_flag    := false;
	bool          field_pic_flag;
	bool          bottom_field_flag;
	uint(size=16) idr_pic_id                    := 0;
	int (size=32) pic_order_cnt_lsb             := 0;
	int (size=32) delta_pic_order_cnt_bottom    := 0;
	uint(size=7)  redundant_pic_cnt             := 0;
	uint(size=2)  cabac_init_idc                := 0;
	//int (size=32) slice_qp_delta;
	bool          sp_for_switch_flag;
	uint(size=6)  slice_qs_delta;
	uint(size=2)  disable_deblocking_filter_idc := 0;
	int(size=6)   slice_alpha_c0_offset         := 0;
	int(size=6)   slice_beta_offset             := 0;
	uint(size=32) slice_group_change_cycle      := 0;
	//Sps Parameters
	uint(size=6)  log2_max_frame_num;
	bool          frame_mbs_only_flag;
	uint(size=2)  pic_order_cnt_type;
	uint(size=6)  SzMaxPocLsb;
	bool          delta_pic_order_always_zero_flag;
	uint(size=8)  num_ref_frames_in_pic_order_cnt_cycle := 0;
	int (size=32) expected_delta_per_poc_cycle          := 0;
	int (size=32) offset_for_non_ref_pic                := 0;
	int (size=32) offset_for_top_to_bottom_field        := 0;
	bool          mb_adaptive_frame_field_flag          := false;
	//PpsParameters
	bool          pic_order_present_flag;
	bool          redundant_pic_cnt_present_flag;
	bool          entropy_coding_mode_flag;
	bool          deblocking_filter_control_present_flag;
	uint(size=4)  num_slice_groups;
	uint(size=3)  slice_group_map_type;
	int (size=32) SzSliceGroupChgCycle;
	int (size=8)  ValPicInitQp;
	//Poc parameters
	int (size=32) prev_frame_num         := 0;
	int (size=32) frame_num_offset       := 0;
	int (size=32) PicOrderCntMsb         := 0;
	int (size=32) prevPicOrderCntLsb     := 0;
	uint(size=2)  nal_ref_idc            := 0;
	int (size=32) expectedpoc            := 0;
	//Slice Data Parameters
	bool          MbaffFrameFlag := false;
	int (size=32) LoopVal;
	bool IsNewPic;

	ResetPrevFrameNum.Launch: action RstPrevFrameNum :[ResetAsked] ==>
	guard
		IsNewPic
	do
		if(ResetAsked) then
			frame_num := 0;
		end
	end

	ResetPrevFrameNum.Skip: action ==>
	guard
		not IsNewPic
	end

	//                                          first_ , slice_ , pic_par
	ReadSliceType.Asked: action ==> TypeOfVLD :[VLD_UE , VLD_UE , VLD_UE]
	do
		disable_deblocking_filter_idc := 0;
		slice_alpha_c0_offset         := 0;
		slice_beta_offset             := 0;
	end

	ReadSliceType.Done: action
		ValVLD         :[ValueOfVLD] repeat 3
			==>
		SliceDataParam  :[slice_type,ValueOfVLD[0]],
		GetPps          :[ValueOfVLD[2]],
		SliceType       :[slice_type],
		Others_IsNewPic :[IsNewPic]
	do
		first_mb_in_slice := ValueOfVLD[0];
		IsNewPic          := (first_mb_in_slice = 0);
		slice_type        :=
			if( ValueOfVLD[1] < 5) then
				ValueOfVLD[1]
			else
				ValueOfVLD[1] - 5
			end;
		if(DEBUG_FLAG_DECODED)then
			println("\t\tfirst_mb_in_slice:"+first_mb_in_slice);
			println("\t\tslice_type:       "+ValueOfVLD[1]);
			println("\t\tpps_id:           "+ValueOfVLD[2]);
		end
		//pps_id            := ValueOfVLD[2]; ==> don't need
		//Ask sps_id
		//Ask and get separate_colour_plane_flag ==> not implemented in decodeSpsHeader yet !!
	end

	SeparateColourPlane.IsEqualToTrue: action
			==>
		//           colour_plane_id
		TypeOfVLD :[ READ_BITS ],
		VLDParam  :[     2     ]
	guard
		separate_colour_plane_flag = true
	end

	ReadFrameNum.Asked: action
		SpsParameters :[SpsParam] repeat 10
			==>
		//                frame_num
		TypeOfVLD :[   READ_BITS   ],
		VLDParam  :[ log2_max_frame_num ],
		Width          :[SpsParam[8]],
		Height         :[SpsParam[9]]
	do
		expected_delta_per_poc_cycle           := SpsParam[0];
		log2_max_frame_num                     := SpsParam[1];
		num_ref_frames_in_pic_order_cnt_cycle  := SpsParam[2];
		offset_for_top_to_bottom_field         := SpsParam[3];
		offset_for_non_ref_pic                 := SpsParam[4];
		SzMaxPocLsb                            := SpsParam[5];
		pic_order_cnt_type                     := SpsParam[6];
		mb_adaptive_frame_field_flag           := GetFlag(SpsParam[7],0);
		delta_pic_order_always_zero_flag       := GetFlag(SpsParam[7],1);
		frame_mbs_only_flag                    := GetFlag(SpsParam[7],2);
	end

	ReadFrameNum.Done.IsNewPic: action
		ValVLD        :[ValueOfVLD],
		PpsParameters :[PpsParam] repeat 5,
		IsAnIdrPic    :[IdrPic],
		NalRefIdc     :[ValNalRefIdc]
			==>
		FramNumCurrPic                    :[ValueOfVLD]
	guard
		IsNewPic
	do
		num_slice_groups                       := PpsParam[0];
		ValPicInitQp                           := PpsParam[1];
		SzSliceGroupChgCycle                   := PpsParam[2];
		slice_group_map_type                   := PpsParam[3];
		deblocking_filter_control_present_flag := GetFlag(PpsParam[4],0);
		pic_order_present_flag                 := GetFlag(PpsParam[4],1);
		redundant_pic_cnt_present_flag         := GetFlag(PpsParam[4],2);
		entropy_coding_mode_flag               := GetFlag(PpsParam[4],3);
		prev_frame_num                         := frame_num;
		Idr_flag                               := IdrPic;
		nal_ref_idc                            := ValNalRefIdc;
		frame_num                              := ValueOfVLD;
		if(DEBUG_FLAG_DECODED)then
			println("\t\tframe_num:        "+ValueOfVLD);
		end
		LoopVal := 0;
	end

	ReadFrameNum.Done.IsNewSlice: action
		ValVLD        :[ValueOfVLD],
		PpsParameters :[PpsParam] repeat 5,
		IsAnIdrPic    :[IdrPic],
		NalRefIdc     :[ValNalRefIdc]
			==>
	guard
		not IsNewPic
	do
		num_slice_groups                       := PpsParam[0];
		ValPicInitQp                           := PpsParam[1];
		SzSliceGroupChgCycle                   := PpsParam[2];
		slice_group_map_type                   := PpsParam[3];
		deblocking_filter_control_present_flag := GetFlag(PpsParam[4],0);
		pic_order_present_flag                 := GetFlag(PpsParam[4],1);
		redundant_pic_cnt_present_flag         := GetFlag(PpsParam[4],2);
		entropy_coding_mode_flag               := GetFlag(PpsParam[4],3);
		Idr_flag                               := IdrPic;
		nal_ref_idc                            := ValNalRefIdc;
		frame_num                              := ValueOfVLD;
		if(DEBUG_FLAG_DECODED)then
			println("\t\tframe_num:        "+ValueOfVLD);
		end
		LoopVal := 0;
	end

	GetOff4RefFrameAcc.Launch: action SpsParameters:[ValOffAccumul] ==>
	guard
		LoopVal <= num_ref_frames_in_pic_order_cnt_cycle
	do
		offset_for_ref_frame_accumul[LoopVal] := ValOffAccumul;
		LoopVal := LoopVal + 1;
	end

	GetOff4RefFrameAcc.Done: action ==>
	guard
		LoopVal >= num_ref_frames_in_pic_order_cnt_cycle
	end

	//                                             field_pic_flag
	FrameMbsOnly.IsEqToFalse: action ==> TypeOfVLD :[ READ_BITS ], VLDParam :[1]
	guard
		frame_mbs_only_flag = false
	end

	ReadFieldPicFlag.Done: action ValVLD :[ValueOfVLD] ==>
	do
		field_pic_flag := 
			if(ValueOfVLD = 0) then
				false
			else
				true
			end;
		MbaffFrameFlag := (field_pic_flag and mb_adaptive_frame_field_flag);
		if(DEBUG_FLAG_DECODED)then
			println("\t\tfield_pic_flag:   "+field_pic_flag);
		end
	end

	FieldPicFlag.IsEqualToTrue: action
				==>
			//           bottom_field_flag
			TypeOfVLD :[ READ_BITS ],
			VLDParam  :[     1     ]
		guard
			field_pic_flag = true
		end

	ReadBottomField.Done: action ValVLD :[ValueOfVLD] ==>
	do
		bottom_field_flag :=
			if(ValueOfVLD = 0)then
				false
			else
				true
			end;
		if(DEBUG_FLAG_DECODED)then
			println("\t\tbottom_field_flag: "+bottom_field_flag);
		end
	end


	IdrFlag.IsEqualToFalse: action ==>
	guard
		Idr_flag = false
	do
		if(frame_num < prev_frame_num) then
			frame_num_offset := frame_num_offset + 1 << log2_max_frame_num;
		end
	end

	//                                           idr_pic_id
	IdrFlag.IsEqualToTrue: action ==> TypeOfVLD :[ VLD_UE ]
	guard
		Idr_flag = true
	do
		frame_num_offset := 0;
		frame_num        := 0;
		prev_frame_num   := 0;
		PicOrderCntMsb         := 0;
		prevPicOrderCntLsb     := 0;
		expectedpoc            := 0;
	end

	ReadIdrPicId.Done: action ValVLD :[ValueOfVLD] ==>
	do
		idr_pic_id := ValueOfVLD;
		if(DEBUG_FLAG_DECODED)then
			println("\t\tidr_pic_id:       "+idr_pic_id);
		end
	end

	PocType.IsEqualTo0: action
			==>
		//           pic_order_cnt_lsb
		TypeOfVLD :[  READ_BITS  ],
		VLDParam  :[ SzMaxPocLsb ]
	guard
		pic_order_cnt_type = 0
	end

	ReadPocLsb.Done.IsNewPic: action ValVLD :[ValueOfVLD] ==> Poc :[POC_val]
	guard
		IsNewPic
	var
		int MaxPicOrderCntLsb,
		int POC_val
	do
		MaxPicOrderCntLsb := (1 << SzMaxPocLsb) / 2;
		if Idr_flag = true then
			PicOrderCntMsb := 0;
			prevPicOrderCntLsb := 0;
		else
			prevPicOrderCntLsb := pic_order_cnt_lsb;
		end
		pic_order_cnt_lsb := ValueOfVLD;
		if  (pic_order_cnt_lsb < prevPicOrderCntLsb) and ((prevPicOrderCntLsb - pic_order_cnt_lsb) >= MaxPicOrderCntLsb) then
			PicOrderCntMsb     :=  PicOrderCntMsb + MaxPicOrderCntLsb;
			prevPicOrderCntLsb := 0;
		else 
			if (pic_order_cnt_lsb > prevPicOrderCntLsb) and ((prevPicOrderCntLsb - pic_order_cnt_lsb) > MaxPicOrderCntLsb) then 
				PicOrderCntMsb := PicOrderCntMsb - MaxPicOrderCntLsb;
			end
		end
		POC_val := PicOrderCntMsb + pic_order_cnt_lsb;
		if(DEBUG_FLAG_DECODED)then
			println("\t\tpic_order_cnt_lsb: "+ValueOfVLD);
		end
		if(DEBUG_FLAG_DECODED)then
			println("PocVal: "+POC_val);
		end
	end

	ReadPocLsb.Done.IsNewSlice: action ValVLD :[ValueOfVLD] ==>
	guard
		not IsNewPic
	end

	//                                 delta_pic_order_cnt_bottom
	//                                            or
	//                                  delta_pic_order_cnt[ 1 ]
	Check_PicOrPres_FieldPic: action ==> TypeOfVLD :[ VLD_SE ]
	guard
		pic_order_present_flag = true,
		field_pic_flag         = false
	end

	ReadDeltaPicOrderCntBottom.Done: action ValVLD :[ValueOfVLD] ==>
	do
		delta_pic_order_cnt_bottom := ValueOfVLD;
		if(DEBUG_FLAG_DECODED)then
			println("\t\tdelta_pic_order_cnt_bottom: "+delta_pic_order_cnt_bottom);
		end
	end

	PocType.IsEqualTo2.IsNewPic: action ==> Poc :[POC_val]
	guard
		IsNewPic
	var
		int POC_val
	do
		POC_val :=
			if(Idr_flag = true) then
				0
			else
				if(nal_ref_idc > 0) then
					(frame_num_offset + frame_num) * 2
				else
					((frame_num_offset + frame_num) * 2) - 1
				end
			end;
		if(DEBUG_FLAG_DECODED)then
			println("PocVal: "+POC_val);
		end
	end

	PocType.IsEqualTo2.IsNewSlice: action ==>
	guard
		not IsNewPic
	end

	PocType.IsEqualTo1: action ==>
	guard
		pic_order_cnt_type = 1
	var
		int abs_frame_num,
		int idx
	do
		abs_frame_num :=
			if(num_ref_frames_in_pic_order_cnt_cycle != 0) then
				frame_num_offset + frame_num
			else
				0
			end ;
		if( (nal_ref_idc = 0) and (abs_frame_num > 0) ) then
			abs_frame_num := abs_frame_num -1;
		end
		if(abs_frame_num > 0) then
			expectedpoc := expected_delta_per_poc_cycle * ((abs_frame_num - 1) / num_ref_frames_in_pic_order_cnt_cycle);
			idx         := (abs_frame_num - 1) mod num_ref_frames_in_pic_order_cnt_cycle;
			expectedpoc := expectedpoc + offset_for_ref_frame_accumul[idx];
		else
			expectedpoc :=0;
		end
		if(nal_ref_idc = 0) then
			expectedpoc := expectedpoc + offset_for_non_ref_pic;
		end
		delta_pic_order_cnt[0] := 0;
	end

	//                                      delta_pic_order_cnt[ 0 ]
	ReadDeltaPicOrCnt0.Asked: action ==> TypeOfVLD :[ VLD_SE ]
	guard
		pic_order_cnt_type               = 1,
		not delta_pic_order_always_zero_flag
	end

	ReadDeltaPicOrCnt0.Done: action ValVLD :[ValueOfVLD] ==>
	do
		delta_pic_order_cnt[0] := ValueOfVLD;
		if(DEBUG_FLAG_DECODED)then
			println("\t\tdelta_pic_order_cnt[0]: "+delta_pic_order_cnt[0]);
		end
	end

	ReadDeltaPicOrCnt1.Done: action ValVLD :[ValueOfVLD] ==>
	do
		delta_pic_order_cnt[1] := ValueOfVLD;
		if(DEBUG_FLAG_DECODED)then
			println("\t\tdelta_pic_order_cnt[1]: "+delta_pic_order_cnt[1]);
		end
	end

	CalcPOC4PocType1.IsNewPic: action ==> Poc :[expectedpoc + 
	                                             delta_pic_order_cnt[0]]
	guard
		IsNewPic
	do
		if(DEBUG_FLAG_DECODED)then
			println("PocVal: "+(expectedpoc+delta_pic_order_cnt[0]));
		end
	end

	CalcPOC4PocType1.IsNewSlice: action ==>
	guard
		not IsNewPic
	end

	//                                                redundant_pic_cnt
	RedundPicCntPres.IsEqualToTrue: action ==> TypeOfVLD :[ VLD_UE ]
	guard
		redundant_pic_cnt_present_flag = true
	end

	ReadRedunPicCnt.Done: action ValVLD :[ValueOfVLD] ==>
	do
		redundant_pic_cnt := ValueOfVLD;
		if(DEBUG_FLAG_DECODED)then
			println("\t\tredundant_pic_cnt: "+redundant_pic_cnt);
		end
	end

	RefPicList.Launch: action
			==>
		TypeOfVLD :[LAUNCH_ACTOR],
		VLDParam  :[REF_PIC_LIST]
	end

	SendSliceDataParameters: action
			==>
		SliceDataParam :[if MbaffFrameFlag then 1 else 0 end]
	end

	DecRefPicMarking.Launch: action
			==>
		TypeOfVLD          :[LAUNCH_ACTOR],
		VLDParam           :[DEC_REF_PIC_MARKING],
		RefPicMrk_IsNewPic :[IsNewPic]
	end

	//                                         cabac_init_idc
	ReadCabacInitDc.Asked: action ==> TypeOfVLD :[ VLD_UE ]
	guard
		entropy_coding_mode_flag  = true,
		slice_type               != SLICE_TYPE_I,
		slice_type               != SLICE_TYPE_SI
	end

	ReadCabacInitDc.Done: action ValVLD :[VLDecoding] ==>
	do
		cabac_init_idc := VLDecoding;
		if(DEBUG_FLAG_DECODED)then
			println("\t\tcabac_init_idc: "+cabac_init_idc);
		end
	end

	//                                         slice_qp_delta
	ReadSliceQpDelta.Asked: action ==> TypeOfVLD :[ VLD_SE ]
	end

	ReadSliceQpDelta.Done: action ValVLD :[VLDec] ==> SliceDataParam :[ValOfQp]
	var
		int(size=8) ValOfQp
	do
		//slice_qp_delta := VLDecoding;
		ValOfQp      := VLDec + ValPicInitQp;
		if(DEBUG_FLAG_DECODED)then
			println("\t\tslice_qp_delta: "+VLDec);
		end
	end

	Slice_Type.IsEqualToSP: action
			==>
		//              sp_for_sw , slice_q
		TypeOfVLD :[ READ_BITS , VLD_SE ],
		VLDParam  :[     1              ]
	guard
		slice_type = SLICE_TYPE_SP
	end

	ReadSliceSpParameters.Done: action ValVLD :[VLDecoding] repeat 2 ==>
	do
		sp_for_switch_flag :=
			if(VLDecoding[0] = 0)then
				false
			else
				true
			end;
		slice_qs_delta := VLDecoding[1];
		if(DEBUG_FLAG_DECODED)then
			println("\t\tsp_for_switch_flag: "+sp_for_switch_flag);
			println("\t\tslice_qs_delta: "+slice_qs_delta);
		end
	end

	//                                          slice_qs_delta
	Slice_Type.IsEqualToSI: action ==> TypeOfVLD :[ VLD_SE ]
	guard
		slice_type = SLICE_TYPE_SP
	end

	ReadSliceSiParameters.Done: action ValVLD :[VLDecoding] ==>
	do
		slice_qs_delta := VLDecoding;
		if(DEBUG_FLAG_DECODED)then
			println("\t\tslice_qs_delta: "+slice_qs_delta);
		end
	end

	//                                       slice_qs_delta
	DeblocFilterPresent: action ==> TypeOfVLD :[ VLD_UE ]
	guard
		deblocking_filter_control_present_flag = true
	end

	ReadDisDeblocFilterIdc.Done: action ValVLD :[VLDecoding] ==>
	do
		disable_deblocking_filter_idc := VLDecoding;
		if(DEBUG_FLAG_DECODED)then
			println("\t\tdisable_deblocking_filter_idc: "+disable_deblocking_filter_idc);
		end
	end

	//                                                       slice_ , slice_
	DisDeblocFilterIdc.IsNotEqualTo1: action ==> TypeOfVLD :[VLD_SE , VLD_SE]
	guard
		disable_deblocking_filter_idc != 1
	end

	ReadSliceAlphaAndBeta: action ValVLD :[VLDecoding] repeat 2 ==>
	do
		slice_alpha_c0_offset := VLDecoding[0] * 2;
		slice_beta_offset     := VLDecoding[1] * 2;
		if(DEBUG_FLAG_DECODED)then
			println("\t\tslice_alpha_c0_offset_div2: "+VLDecoding[0]);
			println("\t\tslice_beta_offset_div2: "+VLDecoding[1]);
		end
	end

	ReadSlcGrpChgCycl.Asked: action
			==>
		//            slice_group_change_cycle
		TypeOfVLD :[       READ_BITS      ],
		VLDParam  :[ SzSliceGroupChgCycle ]
	guard
		num_slice_groups     >  1,
		slice_group_map_type >= 3,
		slice_group_map_type <= 5
	end

	ReadSlcGrpChgCycl.Done: action ValVLD :[VLDecoding] ==>
	do
		slice_group_change_cycle := VLDecoding;
		if(DEBUG_FLAG_DECODED)then
			println("\t\tslice_group_change_cycle: "+slice_group_change_cycle);
		end
	end

	SendEndSliceHeader: action
			==>
		SliceDataParam :[disable_deblocking_filter_idc , slice_beta_offset,
		                 slice_alpha_c0_offset],
		TypeOfVLD              :[SKIP_NAL],
		DecodeNextNal          :[true]
	end

	schedule fsm ReadSliceTypeAsked:
		ReadResetPrevFrameNum          (ResetPrevFrameNum                 )--> ReadSliceTypeAsked;

		ReadSliceTypeAsked             (ReadSliceType.Asked               )--> ReadSliceTypeDone;

		ReadSliceTypeDone              (ReadSliceType.Done                )--> CheckSeparateColourPlane;

		CheckSeparateColourPlane       (SeparateColourPlane.IsEqualToTrue )--> undefined; //Not implemented yet
		CheckSeparateColourPlane       (ReadFrameNum.Asked                )--> ReadFrameNumDone;

		ReadFrameNumDone               (ReadFrameNum.Done                 )--> GetOff4RefFrameAcc;

		GetOff4RefFrameAcc             (GetOff4RefFrameAcc.Launch         )--> GetOff4RefFrameAcc;
		GetOff4RefFrameAcc             (GetOff4RefFrameAcc.Done           )--> CheckFrameMbsOnly;

		CheckFrameMbsOnly              (FrameMbsOnly.IsEqToFalse          )--> ReadFieldPicFlagDone;
		CheckFrameMbsOnly              (IdrFlag.IsEqualToFalse            )--> CheckPocType;
		CheckFrameMbsOnly              (IdrFlag.IsEqualToTrue             )--> ReadIdrPicIdDone;
	

		ReadFieldPicFlagDone           (ReadFieldPicFlag.Done             )-->CheckFieldPicFlag;

		CheckFieldPicFlag              (FieldPicFlag.IsEqualToTrue        )--> ReadBottomFieldDone;
		CheckFieldPicFlag              (IdrFlag.IsEqualToFalse            )--> CheckPocType;
		CheckFieldPicFlag              (IdrFlag.IsEqualToTrue             )--> ReadIdrPicIdDone;

		ReadBottomFieldDone            (ReadBottomField.Done              )-->CheckIdrFlag;

		CheckIdrFlag                   (IdrFlag.IsEqualToFalse            )--> CheckPocType;
		CheckIdrFlag                   (IdrFlag.IsEqualToTrue             )--> ReadIdrPicIdDone;

		ReadIdrPicIdDone               (ReadIdrPicId.Done                 )--> CheckPocType;

		CheckPocType                   (PocType.IsEqualTo0                )--> ReadPocLsbDone;
		CheckPocType                   (PocType.IsEqualTo1                )--> CheckDeltaPicOrderFlag;
		CheckPocType                   (PocType.IsEqualTo2                )--> CheckRedundPicCntPres;

		ReadPocLsbDone                 (ReadPocLsb.Done                   )--> Check4DeltPicOrdCntBot;

		Check4DeltPicOrdCntBot         (Check_PicOrPres_FieldPic          )--> ReadDeltaPicOrderCntBottomDone;
		Check4DeltPicOrdCntBot         (RedundPicCntPres.IsEqualToTrue    )--> ReadRedunPicCntDone;
		Check4DeltPicOrdCntBot         (RefPicList.Launch                 )--> SendSliceDataParameters;

		ReadDeltaPicOrderCntBottomDone (ReadDeltaPicOrderCntBottom.Done   )--> CheckRedundPicCntPres;

		CheckDeltaPicOrderFlag         (ReadDeltaPicOrCnt0.Asked          )--> ReadDeltaPicOrCnt0Done;
		CheckDeltaPicOrderFlag         (CalcPOC4PocType1                  )--> CheckRedundPicCntPres;

		ReadDeltaPicOrCnt0Done         (ReadDeltaPicOrCnt0.Done           )--> Check4DeltaPicOrCnt1;

		Check4DeltaPicOrCnt1           (Check_PicOrPres_FieldPic          )--> ReadDeltaPicOrCnt1Done;
		Check4DeltaPicOrCnt1           (CalcPOC4PocType1                  )--> CheckRedundPicCntPres;

		ReadDeltaPicOrCnt1Done         (ReadDeltaPicOrCnt1.Done           )--> CalcPOC4PocType1;

		CalcPOC4PocType1               (CalcPOC4PocType1                  )--> CheckRedundPicCntPres;

		CheckRedundPicCntPres          (RedundPicCntPres.IsEqualToTrue    )--> ReadRedunPicCntDone;
		CheckRedundPicCntPres          (RefPicList.Launch                 )--> SendSliceDataParameters;

		ReadRedunPicCntDone            (ReadRedunPicCnt.Done              )--> DecodeRefPicList;

		DecodeRefPicList               (RefPicList.Launch                 )--> SendSliceDataParameters;

		SendSliceDataParameters        (SendSliceDataParameters           )-->                             DecodeDecRefPicMarking;//DecodeWeightedPred;
		//DecodeWeightedPred           (LaunchWeightedPred                )--> ...;

		DecodeDecRefPicMarking         (DecRefPicMarking.Launch           )--> CheckEntropyCodingMode;

		CheckEntropyCodingMode         (ReadCabacInitDc.Asked             )--> ReadCabacInitIdc;
		CheckEntropyCodingMode         (ReadSliceQpDelta.Asked            )--> ReadSliceQpDeltaDone;

		ReadCabacInitIdc               (ReadCabacInitDc.Done              )--> ReadSliceQpDeltaAsked;

		ReadSliceQpDeltaAsked          (ReadSliceQpDelta.Asked            )--> ReadSliceQpDeltaDone;

		ReadSliceQpDeltaDone           (ReadSliceQpDelta.Done             )--> CheckSliceType;

		CheckSliceType                 (Slice_Type.IsEqualToSP            )--> ReadSliceSpParameters;
		CheckSliceType                 (Slice_Type.IsEqualToSI            )--> ReadSliceSiParameters;
		CheckSliceType                 (DeblocFilterPresent               )--> ReadDisDeblocFilterIdc;
		CheckSliceType                 (ReadSlcGrpChgCycl.Asked           )--> ReadSlcGrpChgCycl;
		CheckSliceType                 (SendEndSliceHeader                )--> ReadResetPrevFrameNum;

		ReadSliceSpParameters          (ReadSliceSpParameters.Done        )--> CheckDeblocFilterControl;

		ReadSliceSiParameters          (ReadSliceSiParameters.Done        )--> CheckDeblocFilterControl;

		CheckDeblocFilterControl       (DeblocFilterPresent               )--> ReadDisDeblocFilterIdc;
		CheckDeblocFilterControl       (ReadSlcGrpChgCycl.Asked           )--> ReadSlcGrpChgCycl;
		CheckDeblocFilterControl       (SendEndSliceHeader                )--> ReadResetPrevFrameNum;

		ReadDisDeblocFilterIdc         (ReadDisDeblocFilterIdc.Done       )--> CheckDisDeblocFilterIdc;

		CheckDisDeblocFilterIdc        (DisDeblocFilterIdc.IsNotEqualTo1  )--> ReadSliceAlphaAndBeta;
		CheckDisDeblocFilterIdc        (ReadSlcGrpChgCycl.Asked           )--> ReadSlcGrpChgCycl;
		CheckDisDeblocFilterIdc        (SendEndSliceHeader                )--> ReadResetPrevFrameNum;

		ReadSliceAlphaAndBeta          (ReadSliceAlphaAndBeta             )--> CheckNumSliceGroups;

		CheckNumSliceGroups            (ReadSlcGrpChgCycl.Asked           )--> ReadSlcGrpChgCycl;
		CheckNumSliceGroups            (SendEndSliceHeader                )--> ReadResetPrevFrameNum;

		ReadSlcGrpChgCycl              (ReadSlcGrpChgCycl.Done            )--> EndSliceHeader;

		EndSliceHeader                 (SendEndSliceHeader                )--> ReadResetPrevFrameNum;
	end
	priority
		SeparateColourPlane              > ReadFrameNum;
		FrameMbsOnly.IsEqToFalse         > IdrFlag.IsEqualToFalse;
		FieldPicFlag.IsEqualToTrue       > IdrFlag.IsEqualToFalse;
		IdrFlag.IsEqualToFalse           > IdrFlag.IsEqualToTrue;
		PocType.IsEqualTo0               > PocType.IsEqualTo1;
		PocType.IsEqualTo1               > PocType.IsEqualTo2;
		ReadDeltaPicOrCnt0.Asked         > CalcPOC4PocType1;
		Check_PicOrPres_FieldPic         > CalcPOC4PocType1;
		RedundPicCntPres.IsEqualToTrue   > RefPicList.Launch;
		ReadCabacInitDc.Asked            > ReadSliceQpDelta.Asked;
		Slice_Type.IsEqualToSP           > Slice_Type.IsEqualToSI         > DeblocFilterPresent;
		DeblocFilterPresent              > ReadSlcGrpChgCycl.Asked;
		DisDeblocFilterIdc.IsNotEqualTo1 > ReadSlcGrpChgCycl.Asked;
		ReadSlcGrpChgCycl.Asked          > SendEndSliceHeader;
	end
end
