/***********************************************************************

This software module was originally developed by Damien de Saint Jorre IETR/INSA of Rennes (France), in the course of development of the <standard> for reference purposes and its performance may not have been optimized. This software module is an implementation of one or more tools as specified by the MPEG-C part 4.
ISO/IEC gives You a royalty-free, worldwide, non-exclusive, copyright license to copy, distribute, and make derivative works of this software module or modifications thereof for use in implementations of the <standard>  in products that satisfy conformance criteria (if any).
Those intending to use this software module in products are advised that its use may infringe existing patents. ISO/IEC have no liability for use of this software module or modifications thereof.
Copyright is not released for products that do not conform to audiovisual and image-coding related ITU Recommendations and/or ISO/IEC International Standards.
Assurance that the originally developed software module can be used (1) in the <standard> once the <standard> has been adopted; and (2) to develop the MPEG-C part 4:

IETR/INSA of Rennes (France) grants ISO/IEC all rights necessary to include the originally developed software module or modifications thereof in the <standard> and to permit ISO/IEC to offer You a royalty-free, worldwide, non-exclusive, copyright license to copy, distribute, and make derivative works for use in implementations of the MPEG-C part 4 in products that satisfy conformance criteria (if any), and to the extent that such originally developed software module or portions of it are included in the MPEG-C part 4.  To the extent that IETR/INSA of Rennes (France) owns patent rights that would be required to make, use, or sell the originally developed software module or portions thereof included in the MPEG-C part 4 in a conforming product,  IETR/INSA of Rennes (France) will assure the ISO/IEC that it is willing to negotiate licenses under reasonable and non-discriminatory terms and conditions with applicants throughout the world.

ISO/IEC gives You a free license to this software module or modifications thereof for the sole  purpose of developing the MPEG-C part 4

IETR/INSA of Rennes (France) retains full right to modify and use the code for its own purpose, assign or donate the code to a third party and to inhibit third parties from using the code for products that do not conform to MPEG-related ITU Recommendations and/or ISO/IEC International Standards.
This copyright notice must be included in all copies or derivative works. Copyright (c) ISO/IEC 2008.
***********************************************************************/
package Proprietary.IETR.MPEG4.part10.Common;

import Proprietary.IETR.MPEG4.part10.Common.Imp_DecodingFunctions.*;
import MPEG.Common.Imp_Math.*;

actor Algo_DecodeResidualBlock_Cavlc()
	int (size=32) ValVLD,
	int (size=8)  Parameters
		==>
	uint(size=5)  TypeOfVLD,
	int (size=32) VLD_Param,
	uint(size=5)  TotalCoeff,
	int (size=12) Value,
	uint(size=4)  Run,
	bool          Last
		:

	bool DEBUG_FLAG_DECODED = false;

	int (size=8)  nC_Val;
	uint(size=8)  totalCoeff   := 0;
	uint(size=8)  TrailingOnes := 0;
	uint(size=5)  suffixLength := 0;
	uint(size=32) level_prefix := 0;
	uint(size=32) level_suffix := 0;
	uint(size=32) levelCode    := 0;
	uint(size=5)  iLoop        := 0;
	uint(size=4)  zerosLeft    := 0;
	uint(size=5)  maxNumCoeff  := 0;
	uint(size=5)  startIdx     := 0;
	uint(size=5)  endIdx       := 0;
	List(type: uint(size=8) , size=16) CoeffLevel;
	List(type: int (size=16), size=3)  level        := [ 0 : for int i in 1 .. 3];
	List(type: int (size=4) , size=16) run          := [ 0 : for int i in 1 .. 16];

	ReadCoeffToken.Asked: action
		Parameters  :[nC , MaxNumCoeff , StartIdx , EndIdx]
			==>
		//        mb_field_decoding_flag
		TypeOfVLD :[ CAVLC_COEFF_TOKEN ],
		VLD_Param :[       nC       ]
	do
		nC_Val := nC;
		foreach int i in 0 .. 15
		do
			CoeffLevel[i] := 0;
		end
		startIdx    := StartIdx;
		endIdx      := EndIdx;
		maxNumCoeff := MaxNumCoeff;
		if(DEBUG_FLAG_DECODED)then
			println("******************** New Block Cavlc***************************");
			println("nC : "+nC_Val);
		end
		zerosLeft := 0;
	end

	ReadCoeffToken.Done: action ValVLD :[ValOfVLD] ==> TotalCoeff:[totalCoeff]
	do
		totalCoeff   := (ValOfVLD & 0xFF);
		TrailingOnes := (ValOfVLD >> 8);
		if(DEBUG_FLAG_DECODED)then
			println("TotalCoeff : "+(ValOfVLD & 0xFF));
			println("Trailing Ones : "+(ValOfVLD >> 8));
		end
		if(TrailingOnes < 3) then
			levelCode := 2;
		else
			levelCode := 0;
		end
	end

	CheckTotalCoeff.IsGreaterThan0: action ==>
	guard
		totalCoeff > 0
	do
		if((totalCoeff > 10) and (TrailingOnes < 3)) then
			suffixLength := 1;
		else
			suffixLength := 0;
		end
		iLoop     := 0;
	end

	ReadTrailingOnesSign.Asked: action
			==>
		//     trailing_ones_sign_flag
		TypeOfVLD :[ READ_BITS ],
		VLD_Param :[ TrailingOnes ]
	guard
		TrailingOnes > 0
	end

	ReadTrailingOnesSign.Done: action ValVLD :[ValueOfVLD] ==>
	var
		uint(size=1) trailing_ones_sign_flag
	do
		foreach int i in 0 .. TrailingOnes - 1
		do
			trailing_ones_sign_flag := (ValueOfVLD >> (TrailingOnes - 1 - i)) & 1;
			level[iLoop] := 1 - 2 * trailing_ones_sign_flag;
			if(DEBUG_FLAG_DECODED)then
				println("levelT1 : "+level[iLoop]);
			end
			iLoop        := iLoop + 1;
		end
		iLoop := 0;
	end

	SendTrailingOnes: action ==> Value :[level[iLoop-1]], Last :[false]
	guard
		iLoop < TrailingOnes
	do
		iLoop := iLoop + 1;
	end

			//                                      level_prefix
	ReadLevelPrefix.Asked: action ==> TypeOfVLD :[CAVLC_LEVEL_PREFIX]
	guard
		iLoop < totalCoeff
	end

	ReadLevelPrefix.Done: action ValVLD :[ValueOfVLD] ==>
	do
		level_prefix := ValueOfVLD;
		level_suffix := 0;
	end

	ReadLevelSuffix.Asked: action
			==>
		//            level_suffix
		TypeOfVLD :[    READ_BITS    ],
		VLD_Param :[ levelSuffixSize ]
	guard
		   level_prefix >= 14
		or suffixLength  > 0
	var
		int levelSuffixSize
	do
		if((level_prefix = 14) and (suffixLength = 0) )then
			levelSuffixSize := 4;
		else
			if(level_prefix >= 15) then
				levelSuffixSize := level_prefix - 3;
			else
				levelSuffixSize := suffixLength;
			end
		end
	end

	ReadLevelSuffix.Done: action ValVLD :[ValueOfVLD] ==>
	do
		level_suffix := ValueOfVLD;
	end

	ComputeLevel: action ==> Value:[ValLevel], Last :[false]
	var
		int(size=16) ValLevel
	do
		levelCode :=
			if(level_prefix < 15) then
				levelCode + (level_prefix << suffixLength)
			else
				levelCode + (15 << suffixLength)
			end;
		levelCode := levelCode + level_suffix;
		if((level_prefix >= 15) and (suffixLength = 0)) then
			levelCode := levelCode + 15;
		end
		if(level_prefix >= 16) then
			levelCode := levelCode + (1 << (level_prefix - 3)) - 4096;
		end
		if((levelCode mod 2) = 0) then
			ValLevel     := (levelCode + 2) >> 1;
		else
			ValLevel     := (-levelCode - 1) >> 1;
		end

		if(suffixLength = 0)then
			suffixLength := 1;
		end
		if( (Abs(ValLevel) > (3 << suffixLength - 1)) and (suffixLength < 6) ) then
			suffixLength := suffixLength + 1;
		end
		if(DEBUG_FLAG_DECODED)then
			println("level : "+ValLevel);
		end
		
		levelCode := 0;
		iLoop     := iLoop + 1;
	end

	ReadTotalZeros.Asked: action
			==>
		//               total_zeros
		TypeOfVLD :[ CAVLC_TOTAL_ZEROS ],
		VLD_Param :[ maxNumCoeff , totalCoeff ]
	guard
		totalCoeff < (endIdx - startIdx + 1)
	end

	ReadTotalZeros.Done: action ValVLD :[total_zeros] ==>
	do
		zerosLeft := total_zeros;
		if(DEBUG_FLAG_DECODED)then
			println("total_zeros : "+total_zeros);
		end
	end

	InitiLoop: action ==>
	do
		iLoop := 0;
	end

	ZerosLeft.GreaterThan0: action
			==>
		//            run_before
		TypeOfVLD :[ CAVLC_RUN_BEFORE ],
		VLD_Param :[ zerosLeft ]
	guard
		iLoop     < totalCoeff - 1,
		zerosLeft > 0
	end

	ReadRunBefore: action ValVLD :[run_before] ==> Run :[run_before]
	do
		run[iLoop] := run_before;
		if(DEBUG_FLAG_DECODED)then
			println("run_before : "+run_before);
		end
		zerosLeft  := zerosLeft - run_before;
		iLoop      := iLoop + 1;
	end

	SendOthersRun: action ==> Run :[ValRun]
	guard
		iLoop < totalCoeff
	var
		int(size=16) ValRun
	do
		ValRun    := zerosLeft;
		zerosLeft := 0;
		// The first coeffAC will be replaced by coeffDC
		if( (maxNumCoeff = 15) and (iLoop = totalCoeff - 1) )then
			ValRun := ValRun + 1;
		end
		iLoop     := iLoop + 1;
	end

	SendEndResidualBlock: action ==> TypeOfVLD :[SKIP_NAL], Last :[true]
	do
		run[totalCoeff - 1] := zerosLeft;
	end

	schedule fsm ReadCoeffToken_Asked:
		ReadCoeffToken_Asked (ReadCoeffToken.Asked )--> ReadCoeffTokenDone;

		ReadCoeffTokenDone (ReadCoeffToken.Done )--> CheckTotalCoeff;

		CheckTotalCoeff (CheckTotalCoeff.IsGreaterThan0 )--> CheckiLoop;
		CheckTotalCoeff (SendEndResidualBlock )-->ReadCoeffToken_Asked;

		CheckiLoop (ReadTrailingOnesSign.Asked )--> ReadTrailingOnesSign;
		CheckiLoop (ReadLevelPrefix.Asked )--> ReadLevelPrefix;
		CheckiLoop (ReadTotalZeros.Asked )--> ReadTotalZerosDone;
		CheckiLoop (InitiLoop )--> Loop4run;

		ReadTrailingOnesSign (ReadTrailingOnesSign.Done )--> SendTrailingOnes;

		SendTrailingOnes (SendTrailingOnes )--> SendTrailingOnes;
		SendTrailingOnes (ReadLevelPrefix.Asked )--> ReadLevelPrefix;
		SendTrailingOnes (ReadTotalZeros.Asked )--> ReadTotalZerosDone;
		SendTrailingOnes (InitiLoop )--> Loop4run;

		CheckiLoop2 (ReadLevelPrefix.Asked )--> ReadLevelPrefix;
		CheckiLoop2 (ReadTotalZeros.Asked )--> ReadTotalZerosDone;
		CheckiLoop2 (InitiLoop )--> Loop4run;


		ReadLevelPrefix (ReadLevelPrefix.Done )--> ReadLevelSuffixAsked;

		ReadLevelSuffixAsked (ReadLevelSuffix.Asked )--> ReadLevelSuffixDone;
		ReadLevelSuffixAsked (ComputeLevel )--> CheckiLoop2;

		ReadLevelSuffixDone (ReadLevelSuffix.Done )--> ComputeLevel;

		ComputeLevel (ComputeLevel )--> CheckiLoop2;

		ReadTotalZerosDone (ReadTotalZeros.Done )--> InitiLoop;

		InitiLoop (InitiLoop )--> Loop4run;

		Loop4run (ZerosLeft.GreaterThan0 )--> ReadRunBefore;
		Loop4run (SendOthersRun )--> SendOthersRun;
		Loop4run (SendEndResidualBlock )--> ReadCoeffToken_Asked;

		SendOthersRun (SendOthersRun )--> SendOthersRun;
		SendOthersRun (SendEndResidualBlock )--> ReadCoeffToken_Asked;

		ReadRunBefore (ReadRunBefore )--> Loop4run;

		SendEndResidualBlock (SendEndResidualBlock )--> ReadCoeffToken_Asked;
	end
	priority
		CheckTotalCoeff.IsGreaterThan0 > SendEndResidualBlock;
		ReadTrailingOnesSign.Asked > ReadLevelPrefix.Asked;
		ReadLevelSuffix.Asked  > ComputeLevel;
		SendTrailingOnes       > ReadLevelPrefix.Asked;
		ReadLevelPrefix.Asked  > ReadTotalZeros.Asked;
		ReadTotalZeros.Asked   > InitiLoop;
		ZerosLeft.GreaterThan0 > SendOthersRun  > SendEndResidualBlock;
	end
end