/********************************************************************************

This software module was originally developed by 
Damien de Saint Jorre (IETR/INSA of Rennes), 
in the course of development of the ISO/IEC 23002-4 (Video Tool Library) 
for reference purposes and its performance may not have been optimized. 
This software module is an implementation of one or more tools as 
specified by the ISO/IEC 23002-4.

ISO/IEC gives You a royalty-free, worldwide, non-exclusive, copyright 
license to copy, distribute, and make derivative works of this software 
module or modifications thereof for use in implementations of the 
ISO/IEC 23002-4 in products that satisfy conformance criteria (if any). 

Those intending to use this software module in products are advised that 
its use may infringe existing patents. ISO/IEC have no liability for use 
of this software module or modifications thereof.

Copyright is not released for products that do not conform to audiovisual 
and image-coding related ITU Recommendations and/or ISO/IEC International 
Standards. 

Assurance that the originally developed software module can be used 
(1) in the ISO/IEC 23002-4 once the ISO/IEC 23002-4 has been adopted; and 
(2) to develop the ISO/IEC 23002-4: 

IETR/INSA of Rennes grants ISO/IEC all rights necessary to 
include the originally developed software module or modifications thereof 
in the ISO/IEC 23002-4 and to permit ISO/IEC to offer You a royalty-free, 
worldwide, non-exclusive, copyright license to copy, distribute, and make 
derivative works for use in implementations of the ISO/IEC 23002-4 in 
products that satisfy conformance criteria (if any), and to the extent 
that such originally developed software module or portions of it are 
included in the ISO/IEC 23002-4.  To the extent that IETR/INSA of Rennes
owns patent rights that would be required to make, use, or 
sell the originally developed software module or portions thereof 
included in the ISO/IEC 23002-4 in a conforming product, IETR/INSA of
Rennes will assure the ISO/IEC that it is willing to 
negotiate licenses under reasonable and non-discriminatory terms and 
conditions with applicants throughout the world.

ISO/IEC gives You a free license to this software module or modifications 
thereof for the sole  purpose of developing theISO/IEC 23002-4

IETR/INSA of Rennes retains full right to modify and use the 
code for its own purpose, assign or donate the code to a third party and 
to inhibit third parties from using the code for products that do not 
conform to MPEG-related ITU Recommendations and/or ISO/IEC International 
Standards. 

This copyright notice must be included in all copies or derivative works. 
Copyright (c) ISO/IEC 2008.
*****************************************************************************/
package Proprietary.IETR.MPEG4.part10.Common;

import MPEG.MPEG4.part10.Common.Imp_MacroBlockInfo.*;
import MPEG.Common.Imp_Math.*;
import MPEG.Common.Imp_PictureInfo.*;

//Clean me !!!
actor Algo_MvLXReconstr_Frext(bool IsPredL0)
	uint(size=6)  mb_type,
	uint(size=4)  sub_mb_type,
	bool          NewPic_i,

	uint(size=7)  MbLocation,
	bool          NeighbourAvail,
	uint(size=13) CurrMbAddr,
	uint(size=13) FirstMbInSlice,
	uint(size=7)  PicWidthInMb,

	uint(size=4)  MbPredRefIdx,
	uint(size=4)  SubMbPredRefIdx,

	int (size=16) MbPredMvRes,
	int (size=16) SubMbPredMvRes,

	bool          colZeroFlag,

	bool          DirectSpatialMvPredFlag,
	bool          DirectPredLX_In
		==>
	bool          NewPic_o,
	int (size=16) MvOut,
	uint(size=11) Location,
	uint(size=4)  RefIdxOut,
	bool          DirectPredLX_Out
		:


	List(type: uint(size=2), size=16) TabIdxToX =
		[ 0, 1, 0, 1, 2, 3, 2, 3, 0, 1,
		  0, 1, 2, 3, 2, 3];

	List(type: uint(size=2), size=16)TabIdxToY =
		[ 0, 0, 1, 1, 0, 0, 1, 1, 2, 2,
		  3, 3, 2, 2, 3, 3];

	List(type: List(type: uint(size=4),size=4),size=4) Loc_xyToTabIdx =
	[
		[0,2,8,10],
		[1,3,9,11],
		[4,6,12,14],
		[5,7,13,15]
	];

	//Size of MvTab must be >= PicWidthInMb + 1 and must be equal to pow(2,n) for masking bits easily.
	List(type: List(type: List(type: int(size=16),size=2), size=16),size= POW2_PICWIDTH_BLK_PLUS1) MvTab;
	List(type: List(type: int(size=5), size=16),size= POW2_PICWIDTH_BLK_PLUS1) RefIdxTab;

	uint(size=3)             MbPartIdxMax;
	uint(size=3)             MbPartIdx;
	uint(size=3)             SizeMbMv;
	uint(size=3)             SubMbPartIdxMax;
	uint(size=3)             SubMbPartIdx;
	uint(size=3)             SizeSubMbMv;
	uint(size=6)             MbType;
	uint(size=4)             SubMbType;
	uint(size=LOG2_POW2_PICWIDTH_BLK_PLUS1)   Idx_CurrBlk;
	uint(size=1)             Idx_Sub_Tab;
	bool                     IsPred4SubMb;
	int (size=LOG2_POW2_PICWIDTH_BLK_PLUS1+1) Idx_mbAddrA;
	int (size=LOG2_POW2_PICWIDTH_BLK_PLUS1+1) Idx_mbAddrB;
	int (size=LOG2_POW2_PICWIDTH_BLK_PLUS1+1) Idx_mbAddrC;
	int (size=LOG2_POW2_PICWIDTH_BLK_PLUS1+1) Idx_mbAddrD;

	bool          direct_spatial_mv_pred;
	bool          direct_pred_lx;
	uint(size=11) Mbx_in_pix;
	uint(size=11) Mby_in_pix;

		List(type: int (size=16),size=2) MvA;
		List(type: int (size=16),size=2) MvB;
		List(type: int (size=16),size=2) MvC;	
		List(type: int (size=16),size=2) OMv;
	procedure ComputeMvPredL0(int(size=5) RefIdxCurr, int(size=5) Ref_Idx_A, int(size=5) Ref_Idx_B, int(size=5) Ref_Idx_C)
		begin
			OMv :=
				if(Idx_B = -1 and Idx_C = -1)then
					[MvA[0],MvA[1]]
				else
					if(   RefIdxCurr  = Ref_Idx_A and RefIdxCurr != Ref_Idx_B and RefIdxCurr != Ref_Idx_C
					   or RefIdxCurr != Ref_Idx_A and RefIdxCurr  = Ref_Idx_B and RefIdxCurr != Ref_Idx_C
					   or RefIdxCurr != Ref_Idx_A and RefIdxCurr != Ref_Idx_B and RefIdxCurr  = Ref_Idx_C	)then
						if(RefIdxCurr = Ref_Idx_A)then
							[MvA[0],MvA[1]]
						else
							if(RefIdxCurr = Ref_Idx_B)then
								[MvB[0],MvB[1]]
							else
								[MvC[0],MvC[1]]
							end
						end
					else
						[ median(MvA[0],MvB[0],MvC[0]),
						  median(MvA[1],MvB[1],MvC[1]) ]
					end
				end;
		end

			int (size=5) RefIdxA;
			int (size=5) RefIdxB;
			int (size=5) RefIdxC;
			int (size=5) Idx_A;
			int (size=5) Idx_B;
			int (size=5) Idx_C;

	procedure GetNeighbourBlockParameters (int(size=5) IdxBlk, uint(size=5) SzBlkMv)
	var
			int (size=4) loc_x,
			int (size=4) loc_y
	begin
			loc_x   := TabIdxToX[IdxBlk&15];
			loc_y   := TabIdxToY[IdxBlk&15];
			SzBlkMv := SzBlkMv / 4;
			if(loc_x != 0 and loc_y != 0)then
				Idx_A   := Loc_xyToTabIdx[(loc_x-1)&3][loc_y];
				Idx_B   := Loc_xyToTabIdx[loc_x]      [(loc_y-1)&3];
				Idx_C   := Loc_xyToTabIdx[(loc_x-1)&3][(loc_y-1)&3];
				RefIdxA := RefIdxTab[Idx_CurrBlk][Idx_A];
				RefIdxB := RefIdxTab[Idx_CurrBlk][Idx_B];
				RefIdxC := RefIdxTab[Idx_CurrBlk][Idx_C];
				MvA     := [MvTab[Idx_CurrBlk][Idx_A][0],MvTab[Idx_CurrBlk][Idx_A][1]];
				MvB     := [MvTab[Idx_CurrBlk][Idx_B][0],MvTab[Idx_CurrBlk][Idx_B][1]];
				MvC     := [MvTab[Idx_CurrBlk][Idx_C][0],MvTab[Idx_CurrBlk][Idx_C][1]];
			else
				if(loc_x = 0 and loc_y = 0)then
					if(Idx_mbAddrA = -1)then
						Idx_A   := -1;
						RefIdxA := -1;
 						MvA     := [0,0];
					else
						Idx_A   := 5;
						RefIdxA := RefIdxTab[Idx_mbAddrA][5];
						MvA     := [MvTab[Idx_mbAddrA][5][0],MvTab[Idx_mbAddrA][5][1]];
					end
					if(Idx_mbAddrB = -1)then
						Idx_B   := -1;
						RefIdxB := -1;
						MvB     := [0,0];
					else
						Idx_B   := 10;
						RefIdxB := RefIdxTab[Idx_mbAddrB][10];
						MvB     := [MvTab[Idx_mbAddrB][10][0],MvTab[Idx_mbAddrB][10][1]];
					end
					if(Idx_mbAddrD = -1)then
						Idx_C   := -1;
						RefIdxC := -1;
						MvC     := [0,0];
					else
						Idx_C   := 15;
						RefIdxC := RefIdxTab[Idx_mbAddrD][15];
						MvC     := [MvTab[Idx_mbAddrD][15][0],MvTab[Idx_mbAddrD][15][1]];
					end
				else
					if(loc_x != 0 and loc_y = 0)then
						Idx_A   := Loc_xyToTabIdx[(loc_x-1)&3][0];
						RefIdxA := RefIdxTab[Idx_CurrBlk][Idx_A];
						MvA     := [MvTab[Idx_CurrBlk][Idx_A][0],MvTab[Idx_CurrBlk][Idx_A][1]];
						if(Idx_mbAddrB = -1)then
							Idx_B   := -1;
							RefIdxB := -1;
							MvB     := [0,0];
							Idx_C   := -1;
							RefIdxC := -1;
							MvC     := [0,0];
						else
							Idx_B   := Loc_xyToTabIdx[loc_x][3];
							Idx_C   := Loc_xyToTabIdx[(loc_x-1)&3][3];
							RefIdxB := RefIdxTab[Idx_mbAddrB][Idx_B];
							MvB     := [MvTab[Idx_mbAddrB][Idx_B][0],MvTab[Idx_mbAddrB][Idx_B][1]];
							RefIdxC := RefIdxTab[Idx_mbAddrB][Idx_C];
							MvC     := [MvTab[Idx_mbAddrB][Idx_C][0],MvTab[Idx_mbAddrB][Idx_C][1]];	
						end
					else//if(loc_x = 0 and loc_y != 0)
						Idx_B   := Loc_xyToTabIdx[0][(loc_y-1)&3];
						RefIdxB := RefIdxTab[Idx_CurrBlk][Idx_B];
						MvB     := [MvTab[Idx_CurrBlk][Idx_B][0],MvTab[Idx_CurrBlk][Idx_B][1]];
						if(Idx_mbAddrA = -1)then
							Idx_A   := -1;
							RefIdxA := -1;
							MvA     := [0,0];
							Idx_C   := -1;
							RefIdxC := -1;
							MvC     := [0,0];
						else
							Idx_A   := Loc_xyToTabIdx[3][loc_y];
							Idx_C   := Loc_xyToTabIdx[3][(loc_y-1)&3];
							RefIdxA := RefIdxTab[Idx_mbAddrA][Idx_A];
							MvA     := [MvTab[Idx_mbAddrA][Idx_A][0],MvTab[Idx_mbAddrA][Idx_A][1]];
							RefIdxC := RefIdxTab[Idx_mbAddrA][Idx_C];
							MvC     := [MvTab[Idx_mbAddrA][Idx_C][0],MvTab[Idx_mbAddrA][Idx_C][1]];
						end
					end
				end
			end
			loc_x := loc_x + SzBlkMv;
			loc_y := loc_y - 1;
			if(loc_y < 0)then
				if(loc_x <= 3)then
					if(Idx_mbAddrB != -1)then
						Idx_C   := Loc_xyToTabIdx[loc_x][3];
						RefIdxC := RefIdxTab[Idx_mbAddrB][Idx_C];
						MvC     := [MvTab[Idx_mbAddrB][Idx_C][0],MvTab[Idx_mbAddrB][Idx_C][1]];	
					end
				else
					if(Idx_mbAddrC != -1)then
						Idx_C   := Loc_xyToTabIdx[loc_x&3][3];
						RefIdxC := RefIdxTab[Idx_mbAddrC][Idx_C];
						MvC     := [MvTab[Idx_mbAddrC][Idx_C][0],MvTab[Idx_mbAddrC][Idx_C][1]];
					end
				end
			else
				if(loc_x <= 3)then
					//if the macroblock have already been decoded
					if(Loc_xyToTabIdx[loc_x][loc_y&3] < IdxBlk)then
						//We update the values
						Idx_C   := Loc_xyToTabIdx[loc_x][loc_y&3];
						RefIdxC := RefIdxTab[Idx_CurrBlk][Idx_C];
						MvC     := [MvTab[Idx_CurrBlk][Idx_C][0],MvTab[Idx_CurrBlk][Idx_C][1]];
					end
				end
			end
	end

	GetNewPic: action
			NewPic_i :[IsNewPic],
			DirectSpatialMvPredFlag :[DirectSpatMvPred]
				==>
			NewPic_o :[true]
		guard
			IsNewPic
		do
			direct_spatial_mv_pred := DirectSpatMvPred;
		end

	GetMbType.MacroBlkIorSI: action
			mb_type    :[MacroBlkType],
			NewPic_i   :[IsNewPic]
				==>
		guard
			Mb_IsIntra(MacroBlkType),
			not IsNewPic
		end

	GetMbType.P_SkipL0: action
			mb_type    :[MacroBlkType],
			NewPic_i   :[IsNewPic]
				==>
			RefIdxOut :[0],
			NewPic_o  :[false]
		guard
			MacroBlkType = BLOCK_TYPE_P_SKIP,
			IsPredL0,
			not IsNewPic
		do
			MbPartIdx    := 0;
			MbPartIdxMax := 1;
			SizeMbMv     := SZ_16x16;
			MbType       := BLOCK_TYPE_P_L0_16x16;//FixMe
		end

	GetMbType.P_SkipL1: action
			mb_type    :[MacroBlkType],
			NewPic_i   :[IsNewPic]
				==>
		guard
			MacroBlkType = BLOCK_TYPE_P_SKIP,
			not IsPredL0,
			not IsNewPic
		do
			MbPartIdx    := 0;
			MbPartIdxMax := 1;
			SizeMbMv     := SZ_16x16;
			MbType       := BLOCK_TYPE_P_L0_16x16;//FixMe
		end

	List(type: uint(size=11), size=2) Loc_Direct;

	GetMbType.B_Skip_B_Direct_16x16: action
			mb_type          :[MacroBlkType],
			NewPic_i         :[IsNewPic],
			colZeroFlag      :[TabColZero] repeat 4,
			CurrMbAddr       :[Curr_Mb_Addr],
			MbLocation       :[MbLocxInPic , MbLocyInPic],
			NeighbourAvail   :[NeighbourA_Avail , NeighbourB_Avail , NeighbourC_Avail , NeighbourD_Avail],
			FirstMbInSlice   :[Fst_Mb],
			PicWidthInMb     :[pic_width_in_mb]
				==>
			DirectPredLX_Out :[ListDirectPred] repeat 16
		guard
			not IsNewPic,
			MacroBlkType = BLOCK_TYPE_B_SKIP or MacroBlkType = BLOCK_TYPE_B_DIRECT_16x16
		var
			List(type: bool, size=16) ListDirectPred,
			int(size=5) RefIdxLX_Direct
		do
			Mbx_in_pix  := MbLocxInPic*16;
			Mby_in_pix  := MbLocyInPic*16;
			Idx_CurrBlk := Curr_Mb_Addr & MASK_POW2_PICWIDTH_BLK_PLUS1;

			if(not NeighbourA_Avail) then
				Idx_mbAddrA := -1;
			else
				Idx_mbAddrA := (Curr_Mb_Addr - 1) & MASK_POW2_PICWIDTH_BLK_PLUS1;
			end

			if(not NeighbourB_Avail) then
				Idx_mbAddrB := -1;
			else
				Idx_mbAddrB := (Curr_Mb_Addr - pic_width_in_mb) & MASK_POW2_PICWIDTH_BLK_PLUS1;
			end

			if(NeighbourC_Avail)then
				Idx_mbAddrC := (Curr_Mb_Addr - pic_width_in_mb + 1) & MASK_POW2_PICWIDTH_BLK_PLUS1;
			else
				Idx_mbAddrC := -1;
			end
			if(NeighbourD_Avail)then
				Idx_mbAddrD := (Curr_Mb_Addr - pic_width_in_mb - 1) & MASK_POW2_PICWIDTH_BLK_PLUS1;
			else
				Idx_mbAddrD := -1;
			end

			if(direct_spatial_mv_pred)then // spatial prediction
				GetNeighbourBlockParameters (0,16);
				RefIdxLX_Direct := MinPositive(RefIdxA,MinPositive(RefIdxB,RefIdxC));
				direct_pred_lx := (RefIdxLX_Direct >= 0);
				foreach int i in 0 .. 15
				do
					RefIdxTab[Idx_CurrBlk][i] := RefIdxLX_Direct;
					ListDirectPred[i]         := direct_pred_lx;
				end
				foreach int i in 0 .. 3
				do
					if(RefIdxLX_Direct < 0 or RefIdxLX_Direct = 0 and TabColZero[i])then
						foreach int j in 0 .. 3
						do
							MvTab[Idx_CurrBlk][4*i+j] := [0,0];
						end
					else
						ComputeMvPredL0(RefIdxLX_Direct,RefIdxA,RefIdxB,RefIdxC);
						foreach int j in 0 .. 3
						do
							MvTab[Idx_CurrBlk][4*i+j][0] := OMv[0];
							MvTab[Idx_CurrBlk][4*i+j][1] := OMv[1];
						end
					end
				end
			else //temporal prediction
				println("GetMbType.B_Skip_B_Direct_16x16 : temporal prediction for B_Skip not implemented yet !!");
			end
		end

	GetOtherDirectPredLx: action
			DirectPredLX_In :[other_direct_pred_lx]repeat 16
				==>
		do
			if( (not direct_pred_lx) and (not other_direct_pred_lx[0]))then
				foreach int i in 0 .. 15
				do
					RefIdxTab[Idx_CurrBlk][i] := 0;
				end
			end
			direct_pred_lx := direct_pred_lx or (not other_direct_pred_lx[0]);
		end

	SendMv4Direct.Launch: action
				==>
			Location  :[ListLocation] repeat 32,
			MvOut     :[ListMv]       repeat 32,
			RefIdxOut :[ListRefIdx]   repeat 16,
			NewPic_o  :[FalseList]    repeat 16
		guard
			direct_pred_lx
		var
			List(type: uint(size=11), size=32) ListLocation,
			List(type:  int(size=16), size=32) ListMv,
			List(type: uint(size=4) , size=16) ListRefIdx,
			List(type: bool         , size=16) FalseList = [false : for int i in 1 .. 16]
		do
			foreach int mb_part_idx in 0 .. 3
			do
				foreach int sub_mb_part_idx in 0 .. 3
				do
					ListLocation[2* (4*mb_part_idx+sub_mb_part_idx)]     := Mbx_in_pix + 8 *  (mb_part_idx&1) + 4 * (sub_mb_part_idx&1);
					ListLocation[2* (4*mb_part_idx+sub_mb_part_idx) + 1] := Mby_in_pix + 8 * ((mb_part_idx>>1)&1) + 4 * ((sub_mb_part_idx>>1)&1);
					ListMv[2* (4*mb_part_idx+sub_mb_part_idx)]           := MvTab[Idx_CurrBlk][4 * mb_part_idx + sub_mb_part_idx][0];
					ListMv[2* (4*mb_part_idx+sub_mb_part_idx) + 1]       := MvTab[Idx_CurrBlk][4 * mb_part_idx + sub_mb_part_idx][1];
					ListRefIdx[4*mb_part_idx+sub_mb_part_idx]            := RefIdxTab[Idx_CurrBlk][4 * mb_part_idx + sub_mb_part_idx];
				end
			end
		end

	SendMv4Direct.Skip: action ==>
		guard
			not direct_pred_lx
		end

	SendSubMv4Direct.Launch: action
			DirectPredLX_In :[other_direct_pred_lx]
				==>
			Location  :[Loc_Direct] repeat 2,
			MvOut     :[MvTab[Idx_CurrBlk][Idx_Partition][0],MvTab[Idx_CurrBlk][Idx_Partition][1]],
			RefIdxOut :[RefIdxTab[Idx_CurrBlk][Idx_Partition]],
			NewPic_o  :[false]
		guard
			direct_pred_lx or (not other_direct_pred_lx)
		var
			uint Idx_Partition = 4*(MbPartIdx&3) + ((SubMbPartIdx-1)&3)
		do
			if( (not direct_pred_lx) and (not other_direct_pred_lx))then
				RefIdxTab[Idx_CurrBlk][Idx_Partition] := 0;
			end
		end


	SendSubMv4Direct.Skip: action
			DirectPredLX_In :[other_direct_pred_lx]
				==>
		guard
			not direct_pred_lx and other_direct_pred_lx
		end
	GetMbType.Others: action
			mb_type    :[MacroBlkType],
			NewPic_i   :[IsNewPic]
				==>
		guard
			not IsNewPic,
			not Mb_IsIntra(MacroBlkType),
			MacroBlkType != BLOCK_TYPE_P_SKIP,
			MacroBlkType != BLOCK_TYPE_B_SKIP,
			MacroBlkType != BLOCK_TYPE_B_DIRECT_16x16
		do
			Idx_Sub_Tab   :=
				if(Mb_IsBiPred(MacroBlkType)) then
					0
				else
					1
				end;
			MbType        := MacroBlkType;
			MbPartIdx     := 0;
			MbPartIdxMax  := NumMbPart(MacroBlkType);
			SizeMbMv      := SizeMbPart(MacroBlkType);
		end

	EatTokens: action
			CurrMbAddr     :[Curr_Mb_Addr],
			MbLocation     :[MbLocxInPic , MbLocyInPic],
			NeighbourAvail :[NeighbourA_Avail , NeighbourB_Avail , NeighbourC_Avail , NeighbourD_Avail],
			FirstMbInSlice :[b],
			PicWidthInMb   :[c]
				==>
		do
			Idx_CurrBlk := Curr_Mb_Addr & MASK_POW2_PICWIDTH_BLK_PLUS1;
			RefIdxTab[Idx_CurrBlk] := [-1: for int i in 0 .. 15];
			MvTab[Idx_CurrBlk]     := [[0,0]: for int i in 0 .. 15];	
		end

	GetMbInfos.P_Skip: action
			CurrMbAddr     :[Curr_Mb_Addr],
			MbLocation     :[MbLocxInPic , MbLocyInPic],
			NeighbourAvail :[NeighbourA_Avail , NeighbourB_Avail , NeighbourC_Avail , NeighbourD_Avail],
			FirstMbInSlice :[Fst_Mb],
			PicWidthInMb   :[pic_width_in_mb]
				==>
			MvOut    :[MvpL0] repeat 2,
			Location :[Mbx_in_pix,Mby_in_pix]
		var
			int (size=5) RefIdxA,
			int (size=5) RefIdxB,
			int (size=5) RefIdxC,

			List(type: int(size=16), size=2)  MvpL0
		do
			Mbx_in_pix := MbLocxInPic*16;
			Mby_in_pix := MbLocyInPic*16;
			Idx_CurrBlk :=  Curr_Mb_Addr      & MASK_POW2_PICWIDTH_BLK_PLUS1;
			Idx_mbAddrA := (Curr_Mb_Addr - 1) & MASK_POW2_PICWIDTH_BLK_PLUS1;
			Idx_mbAddrB := (Curr_Mb_Addr - pic_width_in_mb) & MASK_POW2_PICWIDTH_BLK_PLUS1;
			RefIdxTab[Idx_CurrBlk] := [0: for int i in 0 .. 15];
			//if mbAddrB is not available
			if(not NeighbourB_Avail) then
				MvpL0 := [0,0];
			else
				//if mbAddrA is not available	
				if(not NeighbourA_Avail) then
					MvpL0 := [0,0];
				else
					//if refIdxL0A is equal to 0 and both components of mvL0A are equal to 0
					if(RefIdxTab[Idx_mbAddrA][5] = 0 and MvTab[Idx_mbAddrA][5][0] = 0 and MvTab[Idx_mbAddrA][5][1] = 0) then
						MvpL0 := [0,0];
					else
						//if refIdxL0B is equal to 0 and both components of mvL0B are equal to 0	
						if(RefIdxTab[Idx_mbAddrB][10] = 0 and MvTab[Idx_mbAddrB][10][0] = 0 and MvTab[Idx_mbAddrB][10][1] = 0) then
							MvpL0 := [0,0];	
						else
							if(NeighbourC_Avail)then
								Idx_C       := 10;
								Idx_mbAddrC := (Curr_Mb_Addr - pic_width_in_mb + 1) & MASK_POW2_PICWIDTH_BLK_PLUS1;
								MvC         := [MvTab [Idx_mbAddrC][10][0],MvTab [Idx_mbAddrC][10][1]];
								RefIdxC     := RefIdxTab[Idx_mbAddrC][10];
							else
								Idx_mbAddrC := -1;
								if(NeighbourD_Avail)then
									Idx_C       := 15;
									Idx_mbAddrD := (Curr_Mb_Addr - pic_width_in_mb - 1) & MASK_POW2_PICWIDTH_BLK_PLUS1;
									MvC         := [MvTab [Idx_mbAddrD][15][0],MvTab [Idx_mbAddrD][15][1]];
									RefIdxC     := RefIdxTab[Idx_mbAddrD][15];
								else
									Idx_C   := -1;
									MvC     := [0,0];
									RefIdxC := -1;
								end
							end
							Idx_A   := 5;	
							RefIdxA := RefIdxTab[Idx_mbAddrA][5];
							MvA     := [MvTab[Idx_mbAddrA][5][0] , MvTab [Idx_mbAddrA][5][1]];
							Idx_B   := 10;
							RefIdxB := RefIdxTab[Idx_mbAddrB][10];
							MvB     := [MvTab[Idx_mbAddrB][10][0],MvTab[Idx_mbAddrB][10][1]];
							ComputeMvPredL0(0,RefIdxA,RefIdxB,RefIdxC);
							MvpL0   := [OMv[0],OMv[1]];
						end
					end
				end
			end
			foreach int i in 0 .. 15
			do
				MvTab[Idx_CurrBlk][i][0] := MvpL0[0];
				MvTab[Idx_CurrBlk][i][1] := MvpL0[1];
			end
		end

	GetMbInfos.Others: action
			CurrMbAddr     :[Curr_Mb_Addr],
			MbLocation     :[MbLocxInPic , MbLocyInPic],
			NeighbourAvail :[NeighbourA_Avail , NeighbourB_Avail , NeighbourC_Avail , NeighbourD_Avail],
			FirstMbInSlice :[Fst_Mb],
			PicWidthInMb   :[pic_width_in_mb]	
				==>
		do
			Mbx_in_pix             := MbLocxInPic*16;
			Mby_in_pix             := MbLocyInPic*16;
			Idx_CurrBlk            := Curr_Mb_Addr & MASK_POW2_PICWIDTH_BLK_PLUS1;
			MvTab[Idx_CurrBlk]     := [[0,0]: for int i in 0 .. 15];
			RefIdxTab[Idx_CurrBlk] := [-1: for int i in 0 .. 15];

			if(not NeighbourA_Avail) then
				Idx_mbAddrA := -1;
			else
				Idx_mbAddrA := (Curr_Mb_Addr - 1) & MASK_POW2_PICWIDTH_BLK_PLUS1;
			end

			if(not NeighbourB_Avail) then
				Idx_mbAddrB := -1;
			else
				Idx_mbAddrB := (Curr_Mb_Addr - pic_width_in_mb) & MASK_POW2_PICWIDTH_BLK_PLUS1;
			end
			if(NeighbourC_Avail)then
				Idx_mbAddrC := (Curr_Mb_Addr - pic_width_in_mb + 1) & MASK_POW2_PICWIDTH_BLK_PLUS1;
			else
				Idx_mbAddrC := -1;
			end
			if(NeighbourD_Avail)then
				Idx_mbAddrD := (Curr_Mb_Addr - pic_width_in_mb - 1) & MASK_POW2_PICWIDTH_BLK_PLUS1;
			else
				Idx_mbAddrD := -1;
			end
		end

	ComputeMvLX.Launch16x16: action
			MbPredRefIdx :[RefIdxCurr],
			MbPredMvRes      :[mv_res] repeat 2
				==>
			Location  :[Mbx_in_pix,Mby_in_pix],
			MvOut     :[MvpL0] repeat 2,
			RefIdxOut :[RefIdxCurr],
			NewPic_o  :[false]
		guard
			MbPartIdx < MbPartIdxMax,
			   Mb_Is_PredL0(MbType, MbPartIdx) and IsPredL0
			or Mb_Is_PredL1(MbType, MbPartIdx) and not IsPredL0,
			SizeMbMv = SZ_16x16
		var
			List(type: int(size=16), size=2) MvpL0
		do
			foreach int i in 0 .. 15
			do
				RefIdxTab[Idx_CurrBlk][i] := RefIdxCurr;
			end

			GetNeighbourBlockParameters (0,16);
			ComputeMvPredL0(RefIdxCurr,RefIdxA,RefIdxB,RefIdxC);

			MvpL0[0]:= OMv[0]+mv_res[0];
			MvpL0[1]:= OMv[1]+mv_res[1];

			foreach int i in 0 .. 15
			do
				MvTab[Idx_CurrBlk][i] := [MvpL0[0],MvpL0[1]];
			end

			MbPartIdx := MbPartIdx + 1;
		end

	ComputeMvLX.Launch16x8: action
			MbPredRefIdx :[RefIdxCurr],
			MbPredMvRes  :[mv_res] repeat 2
				==>
			Location     :[Blk_x_in_pix,Blk_y_in_pix],
			MvOut        :[MvpL0] repeat 2,
			RefIdxOut    :[RefIdxCurr],
			NewPic_o     :[false]
		guard
			MbPartIdx < MbPartIdxMax,
			   Mb_Is_PredL0(MbType, MbPartIdx) and IsPredL0
			or Mb_Is_PredL1(MbType, MbPartIdx) and not IsPredL0,
			SizeMbMv = SZ_16x8
		var
			List(type: int(size=16), size=2) MvpL0,
			uint(size=11) Blk_x_in_pix := Mbx_in_pix,
			uint(size=11) Blk_y_in_pix := Mby_in_pix
		do
			foreach int i in 0 .. 7
			do
				RefIdxTab[Idx_CurrBlk][i + 8 * (MbPartIdx&1)] := RefIdxCurr;
			end

			GetNeighbourBlockParameters (8*(MbPartIdx&1),16);
			if(MbPartIdx = 0)then
				if(RefIdxCurr = RefIdxB)then
					MvpL0 := [MvB[0],MvB[1]];
				else
					ComputeMvPredL0(RefIdxCurr,RefIdxA,RefIdxB,RefIdxC);
					MvpL0 := [OMv[0],OMv[1]];	
				end
			else
				Blk_y_in_pix := Blk_y_in_pix + 8;
				if(RefIdxCurr = RefIdxA)then
					MvpL0 := [MvA[0],MvA[1]];
				else
					ComputeMvPredL0(RefIdxCurr,RefIdxA,RefIdxB,RefIdxC);
					MvpL0 := [OMv[0],OMv[1]];
				end
			end

			MvpL0[0] := MvpL0[0] + mv_res[0];
			MvpL0[1] := MvpL0[1] + mv_res[1];

			foreach int i in 0 .. 7
			do
				MvTab[Idx_CurrBlk][i+(8*(MbPartIdx & 1))] := [MvpL0[0],MvpL0[1]];
			end

			MbPartIdx := MbPartIdx + 1;
		end

	ComputeMvLX.Launch8x16: action
			MbPredRefIdx :[RefIdxCurr],
			MbPredMvRes      :[mv_res] repeat 2
				==>
			Location :[Blk_x_in_pix,Blk_y_in_pix],
			MvOut :[MvpL0] repeat 2,
			RefIdxOut :[RefIdxCurr],
			NewPic_o  :[false]
		guard
			MbPartIdx < MbPartIdxMax,
			   Mb_Is_PredL0(MbType, MbPartIdx) and IsPredL0
			or Mb_Is_PredL1(MbType, MbPartIdx) and not IsPredL0,
			SizeMbMv = SZ_8x16
		var
			List(type: int(size=16), size=2) MvpL0,
			uint(size=11) Blk_x_in_pix := Mbx_in_pix,
			uint(size=11) Blk_y_in_pix := Mby_in_pix
		do
			foreach int i in 0 .. 3
			do
				RefIdxTab[Idx_CurrBlk][i + 4 * (MbPartIdx&1)] := RefIdxCurr;
			end
			foreach int i in 8 .. 11
			do
				RefIdxTab[Idx_CurrBlk][i + 4 * (MbPartIdx&1)] := RefIdxCurr;
			end

			GetNeighbourBlockParameters (4*(MbPartIdx&1),8);
			if(MbPartIdx = 0)then
				if(RefIdxCurr = RefIdxA)then
					MvpL0 := [MvA[0],MvA[1]];
				else
					ComputeMvPredL0(RefIdxCurr,RefIdxA,RefIdxB,RefIdxC);
					MvpL0 := [OMv[0],OMv[1]];
				end
			else
				Blk_x_in_pix := Blk_x_in_pix + 8;
				if(RefIdxCurr = RefIdxC)then
					MvpL0 := [MvC[0],MvC[1]];
				else
					ComputeMvPredL0(RefIdxCurr,RefIdxA,RefIdxB,RefIdxC);
					MvpL0 := [OMv[0],OMv[1]];
				end
			end

			MvpL0[0] := MvpL0[0] + mv_res[0];
			MvpL0[1] := MvpL0[1] + mv_res[1];

			foreach int i in 0 .. 3
			do
				MvTab[Idx_CurrBlk][    i+(4*(MbPartIdx & 1))] := [MvpL0[0],MvpL0[1]];
				MvTab[Idx_CurrBlk][8 + i+(4*(MbPartIdx & 1))] := [MvpL0[0],MvpL0[1]];
			end

			MbPartIdx := MbPartIdx + 1;
		end

	ComputeMvLX.Launch8x8: action
			sub_mb_type :[ValSubMbType]
				==>
		guard
			MbPartIdx < MbPartIdxMax,
			SizeMbMv = SZ_8x8
		do
			SubMbPartIdx    := 0;
			SubMbPartIdxMax := NumSubMbPart(MbType,ValSubMbType);
			IsPred4SubMb    :=    ((SubMbPartPredMode[Idx_Sub_Tab][ValSubMbType & 15] & PRED_L0) != 0) and IsPredL0
			                   or ((SubMbPartPredMode[Idx_Sub_Tab][ValSubMbType & 15] & PRED_L1) != 0) and not IsPredL0;
			SizeSubMbMv     := SizeSubMbPart(MbType,ValSubMbType);
			SubMbType       := ValSubMbType;
		end

	ComputeMvLX.Skip: action
				==>
		guard
			MbPartIdx < MbPartIdxMax,
			not (    Mb_Is_PredL0(MbType, MbPartIdx) and IsPredL0
			      or Mb_Is_PredL1(MbType, MbPartIdx) and not IsPredL0),
			SizeMbMv != SZ_8x8
		do
			MbPartIdx := MbPartIdx + 1;
		end

	ComputeMvLX.Done: action ==>
		guard
			MbPartIdx = MbPartIdxMax
		end


	ComputeSubMvLX.Launch8x8: action
			SubMbPredRefIdx :[RefIdxCurr],
			SubMbPredMvRes  :[mv_res] repeat 2
				==>
			Location  :[Blk_x_in_pix,Blk_y_in_pix],
			MvOut     :[MvpL0]repeat 2,
			RefIdxOut :[RefIdxCurr],
			NewPic_o  :[false]
		guard
			SubMbPartIdx < SubMbPartIdxMax,
			IsPred4SubMb,
			SizeSubMbMv = SZ_8x8
		var
			List(type: int(size=16), size=2) MvpL0,
			uint(size=11) Blk_x_in_pix := Mbx_in_pix,
			uint(size=11) Blk_y_in_pix := Mby_in_pix
		do
			Blk_x_in_pix := Blk_x_in_pix + 8 * (MbPartIdx&1);
			Blk_y_in_pix := Blk_y_in_pix + 8 * ((MbPartIdx>>1)&1);

			foreach int i in 0 .. 3
			do
				RefIdxTab[Idx_CurrBlk][4 * (MbPartIdx&3) + i] := RefIdxCurr;
			end

			GetNeighbourBlockParameters (4*(MbPartIdx&3),8);
			ComputeMvPredL0(RefIdxCurr,RefIdxA,RefIdxB,RefIdxC);

			MvpL0[0] := OMv[0]+mv_res[0];
			MvpL0[1] := OMv[1]+mv_res[1];

			foreach int i in 0 .. 3
			do
				MvTab[Idx_CurrBlk][i + 4*(MbPartIdx&3)] := [MvpL0[0],MvpL0[1]];
			end

			SubMbPartIdx := SubMbPartIdx + 1;
		end

	ComputeSubMvLX.LaunchB_Direct_8x8: action
			colZeroFlag :[TabColZero]
				==>
			DirectPredLX_Out :[direct_pred_lx]
		guard
			SubMbPartIdx < SubMbPartIdxMax,
			SubMbPartPredMode[Idx_Sub_Tab][SubMbType & 15] = DIRECT
		var
			int(size=5) RefIdxLX_Direct,
			uint Idx_Partition = 4*(MbPartIdx&3) + (SubMbPartIdx&3)
		do
			Loc_Direct[0] := Mbx_in_pix + 8 * (MbPartIdx&1) + 4*(SubMbPartIdx&1);
			Loc_Direct[1] := Mby_in_pix + 8 * ((MbPartIdx>>1)&1) + 4* ((SubMbPartIdx>>1)&1);

			if(direct_spatial_mv_pred)then // spatial prediction
				GetNeighbourBlockParameters (0,16);
				RefIdxLX_Direct := MinPositive(RefIdxA,MinPositive(RefIdxB,RefIdxC));
				RefIdxTab[Idx_CurrBlk][Idx_Partition] := RefIdxLX_Direct;
				if(RefIdxLX_Direct < 0 or RefIdxLX_Direct = 0 and TabColZero)then
					MvTab[Idx_CurrBlk][Idx_Partition] := [0,0];
				else
					ComputeMvPredL0(RefIdxLX_Direct,RefIdxA,RefIdxB,RefIdxC);
					MvTab[Idx_CurrBlk][Idx_Partition][0] := OMv[0];
					MvTab[Idx_CurrBlk][Idx_Partition][1] := OMv[1];
				end
				direct_pred_lx := (RefIdxLX_Direct >= 0);
			else //temporal prediction
				println("GetMbType.B_Skip_B_Direct_8x8 : temporal prediction for B_Direct_8x8 not implemented yet !!");
			end

			SubMbPartIdx := SubMbPartIdx + 1;
		end

	ComputeSubMvLX.Launch8x4: action
			SubMbPredRefIdx :[RefIdxCurr],
			SubMbPredMvRes  :[mv_res] repeat 2
				==>
			Location  :[Blk_x_in_pix,Blk_y_in_pix],
			MvOut     :[MvpL0] repeat 2,
			RefIdxOut :[RefIdxCurr],
			NewPic_o  :[false]
		guard
			SubMbPartIdx < SubMbPartIdxMax,
			IsPred4SubMb,
			SizeSubMbMv = SZ_8x4
		var
			List(type: int(size=16), size=2) MvpL0,
			uint(size=11) Blk_x_in_pix := Mbx_in_pix,
			uint(size=11) Blk_y_in_pix := Mby_in_pix
		do
			Blk_x_in_pix := Blk_x_in_pix + 8 * (MbPartIdx&1);
			Blk_y_in_pix := Blk_y_in_pix + 8 * ((MbPartIdx>>1)&1) + 4 * (SubMbPartIdx&1);

			RefIdxTab[Idx_CurrBlk][4 * (MbPartIdx&3) + 2 * (SubMbPartIdx&1)]     := RefIdxCurr;
			RefIdxTab[Idx_CurrBlk][4 * (MbPartIdx&3) + 2 * (SubMbPartIdx&1) + 1] := RefIdxCurr;

			GetNeighbourBlockParameters (4*(MbPartIdx&3) + 2*(SubMbPartIdx&1),8);
			ComputeMvPredL0(RefIdxCurr,RefIdxA,RefIdxB,RefIdxC);

			MvpL0[0] := OMv[0]+mv_res[0];
			MvpL0[1] := OMv[1]+mv_res[1];

			MvTab[Idx_CurrBlk][4*(MbPartIdx&3) + 2*(SubMbPartIdx&1)]     := [MvpL0[0],MvpL0[1]];
			MvTab[Idx_CurrBlk][4*(MbPartIdx&3) + 2*(SubMbPartIdx&1) + 1] := [MvpL0[0],MvpL0[1]];

			SubMbPartIdx := SubMbPartIdx + 1;
		end

	ComputeSubMvLX.Launch4x8: action
			SubMbPredRefIdx :[RefIdxCurr],
			SubMbPredMvRes  :[mv_res] repeat 2
				==>
			Location  :[Blk_x_in_pix,Blk_y_in_pix],
			MvOut     :[MvpL0]repeat 2,
			RefIdxOut :[RefIdxCurr],
			NewPic_o  :[false]
		guard
			SubMbPartIdx < SubMbPartIdxMax,
			IsPred4SubMb,
			SizeSubMbMv = SZ_4x8
		var
			List(type: int(size=16), size=2) MvpL0,
			uint(size=11) Blk_x_in_pix := Mbx_in_pix,
			uint(size=11) Blk_y_in_pix := Mby_in_pix
		do
			Blk_x_in_pix := Blk_x_in_pix + 8 * (MbPartIdx&1) + 4 * (SubMbPartIdx&1);
			Blk_y_in_pix := Blk_y_in_pix + 8 * ((MbPartIdx>>1)&1);

			RefIdxTab[Idx_CurrBlk][4 * (MbPartIdx&3) + (SubMbPartIdx&1)]     := RefIdxCurr;
			RefIdxTab[Idx_CurrBlk][4 * (MbPartIdx&3) + (SubMbPartIdx&1) + 2] := RefIdxCurr;
	
			GetNeighbourBlockParameters (4*(MbPartIdx&3) + 1*(SubMbPartIdx&1),4);
			ComputeMvPredL0(RefIdxCurr,RefIdxA,RefIdxB,RefIdxC);

			MvpL0[0] := OMv[0]+mv_res[0];
			MvpL0[1] := OMv[1]+mv_res[1];

			MvTab[Idx_CurrBlk][4*(MbPartIdx&3) + (SubMbPartIdx&1)]     := [MvpL0[0],MvpL0[1]];
			MvTab[Idx_CurrBlk][4*(MbPartIdx&3) + (SubMbPartIdx&1) + 2] := [MvpL0[0],MvpL0[1]];

			SubMbPartIdx := SubMbPartIdx + 1;
		end

	ComputeSubMvLX.Launch4x4: action
			SubMbPredRefIdx :[RefIdxCurr],
			SubMbPredMvRes  :[mv_res] repeat 2
				==>
			Location  :[Blk_x_in_pix,Blk_y_in_pix],
			MvOut     :[MvpL0]repeat 2,
			RefIdxOut :[RefIdxCurr],
			NewPic_o  :[false]
		guard
			SubMbPartIdx < SubMbPartIdxMax,
			IsPred4SubMb,
			SizeSubMbMv = SZ_4x4
		var
			List(type: int(size=16), size=2) MvpL0,
			uint(size=11) Blk_x_in_pix := Mbx_in_pix,
			uint(size=11) Blk_y_in_pix := Mby_in_pix
		do
			Blk_x_in_pix := Blk_x_in_pix + 8 * (MbPartIdx&1) + 4 * (SubMbPartIdx&1);
			Blk_y_in_pix := Blk_y_in_pix + 8 * ((MbPartIdx>>1)&1) + 4 * ((SubMbPartIdx>>1)&1);

			RefIdxTab[Idx_CurrBlk][4 * (MbPartIdx&3) + (SubMbPartIdx&3)]     := RefIdxCurr;

			GetNeighbourBlockParameters (4*(MbPartIdx&3) + 1*(SubMbPartIdx&3),4);
			ComputeMvPredL0(RefIdxCurr,RefIdxA,RefIdxB,RefIdxC);

			MvpL0[0]:= OMv[0]+mv_res[0];
			MvpL0[1]:= OMv[1]+mv_res[1];

			MvTab[Idx_CurrBlk][4*(MbPartIdx&3) + (SubMbPartIdx&3)]     := [MvpL0[0],MvpL0[1]];

			SubMbPartIdx := SubMbPartIdx + 1;
		end

	ComputeSubMvLX.Skip: action
				==>
		guard
			SubMbPartIdx < SubMbPartIdxMax,
			not IsPred4SubMb,
			SubMbPartPredMode[Idx_Sub_Tab][SubMbType & 15] != DIRECT
		do
			SubMbPartIdx := SubMbPartIdx + 1;
		end

	ComputeSubMvLX.Done: action ==>
		guard
			SubMbPartIdx = SubMbPartIdxMax
		do
			MbPartIdx := MbPartIdx + 1;
		end


	schedule fsm GetMbType:
		GetMbType            (GetNewPic                         )--> GetMbType;
		GetMbType            (GetMbType.MacroBlkIorSI           )--> EatTokens;
		GetMbType            (GetMbType.P_SkipL0                )--> GetMbInfos4P_SkipL0;
		GetMbType            (GetMbType.P_SkipL1                )--> EatTokens;
		GetMbType            (GetMbType.B_Skip_B_Direct_16x16   )--> GetOtherDirectPredLx;
		GetMbType            (GetMbType.Others                  )--> GetMbInfos4Others;

		EatTokens            (EatTokens                         )--> GetMbType;

		GetOtherDirectPredLx (GetOtherDirectPredLx              )--> SendMv4Direct;

		SendMv4Direct        (SendMv4Direct                     )--> GetMbType;

		GetMbInfos4P_SkipL0  (GetMbInfos.P_Skip                 )--> GetMbType;

		GetMbInfos4Others    (GetMbInfos.Others                 )--> ComputeMvpL0;

		ComputeMvpL0         (ComputeMvLX.Skip                  )--> ComputeMvpL0;
		ComputeMvpL0         (ComputeMvLX.Launch16x16           )--> ComputeMvpL0;
		ComputeMvpL0         (ComputeMvLX.Launch16x8            )--> ComputeMvpL0;
		ComputeMvpL0         (ComputeMvLX.Launch8x16            )--> ComputeMvpL0;
		ComputeMvpL0         (ComputeMvLX.Launch8x8             )--> ComputeSubMvpL0;
		ComputeMvpL0         (ComputeMvLX.Done                  )--> GetMbType;

		ComputeSubMvpL0      (ComputeSubMvLX.Launch8x8          )--> ComputeSubMvpL0;
		ComputeSubMvpL0      (ComputeSubMvLX.LaunchB_Direct_8x8 )--> SendSubMv4Direct;
		ComputeSubMvpL0      (ComputeSubMvLX.Launch8x4          )--> ComputeSubMvpL0;
		ComputeSubMvpL0      (ComputeSubMvLX.Launch4x8          )--> ComputeSubMvpL0;
		ComputeSubMvpL0      (ComputeSubMvLX.Launch4x4          )--> ComputeSubMvpL0;
		ComputeSubMvpL0      (ComputeSubMvLX.Skip               )--> ComputeSubMvpL0;
		ComputeSubMvpL0      (ComputeSubMvLX.Done               )--> ComputeMvpL0;

		SendSubMv4Direct     (SendSubMv4Direct                  )--> ComputeSubMvpL0;
	end

	priority
		GetMbType.MacroBlkIorSI         > GetMbType.Others;
		GetMbType.P_SkipL0              > GetMbType.Others;
		GetMbType.P_SkipL1              > GetMbType.Others;
		GetMbType.B_Skip_B_Direct_16x16 > GetMbType.Others;
		GetMbType.Others                > GetNewPic;
	end
end