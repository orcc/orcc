/***********************************************************************

This software module was originally developed by Damien de Saint Jorre IETR/INSA of Rennes (France), in the course of development of the <standard> for reference purposes and its performance may not have been optimized. This software module is an implementation of one or more tools as specified by the MPEG-C part 4.
ISO/IEC gives You a royalty-free, worldwide, non-exclusive, copyright license to copy, distribute, and make derivative works of this software module or modifications thereof for use in implementations of the <standard>  in products that satisfy conformance criteria (if any).
Those intending to use this software module in products are advised that its use may infringe existing patents. ISO/IEC have no liability for use of this software module or modifications thereof.
Copyright is not released for products that do not conform to audiovisual and image-coding related ITU Recommendations and/or ISO/IEC International Standards.
Assurance that the originally developed software module can be used (1) in the <standard> once the <standard> has been adopted; and (2) to develop the MPEG-C part 4:

IETR/INSA of Rennes (France) grants ISO/IEC all rights necessary to include the originally developed software module or modifications thereof in the <standard> and to permit ISO/IEC to offer You a royalty-free, worldwide, non-exclusive, copyright license to copy, distribute, and make derivative works for use in implementations of the MPEG-C part 4 in products that satisfy conformance criteria (if any), and to the extent that such originally developed software module or portions of it are included in the MPEG-C part 4.  To the extent that IETR/INSA of Rennes (France) owns patent rights that would be required to make, use, or sell the originally developed software module or portions thereof included in the MPEG-C part 4 in a conforming product,  IETR/INSA of Rennes (France) will assure the ISO/IEC that it is willing to negotiate licenses under reasonable and non-discriminatory terms and conditions with applicants throughout the world.

ISO/IEC gives You a free license to this software module or modifications thereof for the sole  purpose of developing the MPEG-C part 4

IETR/INSA of Rennes (France) retains full right to modify and use the code for its own purpose, assign or donate the code to a third party and to inhibit third parties from using the code for products that do not conform to MPEG-related ITU Recommendations and/or ISO/IEC International Standards.
This copyright notice must be included in all copies or derivative works. Copyright (c) ISO/IEC 2008.
***********************************************************************/
package Proprietary.IETR.MPEG4.part10.Common;

import MPEG.MPEG4.part10.Common.Imp_MacroBlockInfo.*;
import Proprietary.IETR.MPEG4.part10.Common.Imp_DecodingFunctions.*;
import MPEG.Common.Imp_ByteOperation.*;

actor Algo_DecodeSubMbPred()
	int (size=32) ValVLD,

	uint(size=6)  Parameters
		==>
	uint(size=5)  TypeOfVLD,
	int (size=32) VldParam,

	uint(size=4) SubMbType,

	uint(size=4) RefIdxL0,
	uint(size=4) RefIdxL1,
	int(size=16) MvResl0,
	int(size=16) MvResl1
		:

	bool DEBUG_MV = false;


	uint(size=2) B_DIRECT_8x8  = 0;

	List(type: uint(size=2), size=16) SubMbPredMode_B
		=	[  DIRECT , PRED_L0 , PRED_L1 , BIPRED , PRED_L0 , PRED_L0 , PRED_L1 , PRED_L1 , BIPRED , BIPRED 
			, PRED_L0 , PRED_L1 , BIPRED  ,   NA   ,   NA    ,   NA    ];


	uint(size=5)  num_ref_idx_l0_active;
	uint(size=5)  num_ref_idx_l1_active;
	bool          mb_field_decoding_flag;
	uint(size=6)  mb_type;

	uint(size=3) mbPartIdx;
	uint(size=3) subMbPartIdx;
	uint(size=3) subMbPartIdxMax;

	List(type: uint(size=4), size=4) sub_mb_type;
	List (type:int,size=4) ref_idx_l0 := [ 0 : for int i in 0 .. 3];
	List (type:int,size=4) ref_idx_l1 := [ 0 : for int i in 0 .. 3];

	function SubMbPredMode( uint(size=4) ValSubMbType) --> uint(size=2) :
			if(mb_type >= BLOCK_TYPE_B_MIN and mb_type <= BLOCK_TYPE_B_MAX)then
				if(ValSubMbType >12) then
					DIRECT
				else
					SubMbPredMode_B[ValSubMbType]
				end
			else
				if(ValSubMbType < 4)then
					PRED_L0
				else
					DIRECT
				end
			end
		end


	ReadSubMbType.Asked: action
				==>
			TypeOfVLD :[ VLD_UE , VLD_UE , VLD_UE , VLD_UE ]
		end

	ReadSubMbType.Done: action
			ValVLD           :[ValueOfVLD] repeat 4
				==>
			SubMbType :[ValueOfVLD] repeat 4
		do
			foreach int i in 0 .. 3
			do
				sub_mb_type[i] := ValueOfVLD[i];
				if(DEBUG_MV)then
					println("sub_mb_type[ "+i+" ] : "+ValueOfVLD[i]);
				end
			end
		end

	ReadParameters: action
			Parameters :[MacroBType,NumRefIdxL0Act,NumRefIdxL1Act,Flag]
				==>
		do
			num_ref_idx_l0_active  := NumRefIdxL0Act;
			num_ref_idx_l1_active  := NumRefIdxL1Act;
			mb_type                := MacroBType;
			mb_field_decoding_flag := GetFlag(Flag,0);

			mbPartIdx    := 0;
		end

/*
for( mbPartIdx = 0; mbPartIdx < 4; mbPartIdx++ )
   if( ( num_ref_idx_l0_active_minus1 > 0 || mb_field_decoding_flag ) &&
       mb_type != P_8x8ref0 &&
       sub_mb_type[ mbPartIdx ] != B_Direct_8x8 &&
       SubMbPredMode( sub_mb_type[ mbPartIdx ] ) != Pred_L1 )
       	ref_idx_l0[ mbPartIdx ] = te(v)
*/
	AskRefIdxL0.Launch: action
				==>
			TypeOfVLD :[ VLD_TE ],
			VldParam  :[ num_ref_idx_l0_active - 1 ]
		guard
			/* ( num_ref_idx_l0_active_minus1 > 0 || mb_field_decoding_flag ) */
			num_ref_idx_l0_active > 1 or mb_field_decoding_flag,
			/* mb_type != P_8x8ref0 */
			   mb_type != BLOCK_TYPE_P_8x8ref0,
			/* sub_mb_type[ mbPartIdx ] != B_Direct_8x8 */
			not(mb_type >= BLOCK_TYPE_B_MIN and mb_type <= BLOCK_TYPE_B_MAX) or (sub_mb_type[mbPartIdx] != B_DIRECT_8x8),
			/* SubMbPredMode( sub_mb_type[ mbPartIdx ] ) != Pred_L1 )*/
			SubMbPredMode(sub_mb_type[mbPartIdx]) != PRED_L1,

			mbPartIdx < 4
		do
			mbPartIdx := mbPartIdx + 1;
		end

	AskRefIdxLX.Skip: action
				==>
			TypeOfVLD :[ READ_BITS ],
			VldParam  :[ 0 ]
		guard
			mbPartIdx < 4
		do
			mbPartIdx := mbPartIdx + 1;
		end

	SendOrReadDone: action
				==>
		guard
			mbPartIdx = 4
		do
			mbPartIdx := 0;
		end

/*
for( mbPartIdx = 0; mbPartIdx < 4; mbPartIdx++ )
   if( (num_ref_idx_l1_active_minus1 > 0 | | mb_field_decoding_flag ) &&
        sub_mb_type[ mbPartIdx ] != B_Direct_8x8 &&
        SubMbPredMode( sub_mb_type[ mbPartIdx ] ) != Pred_L0 )
           ref_idx_l1[ mbPartIdx ] := te(v);
*/
	AskRefIdxL1.Launch: action
				==>
			TypeOfVLD :[ VLD_TE ],
			VldParam  :[ num_ref_idx_l0_active - 1 ]
		guard
			/* ( num_ref_idx_l1_active_minus1 > 0 | | mb_field_decoding_flag ) */
			num_ref_idx_l1_active > 1 or mb_field_decoding_flag,
			/* sub_mb_type[ mbPartIdx ] != B_Direct_8x8 */
			not(mb_type >= BLOCK_TYPE_B_MIN and mb_type <= BLOCK_TYPE_B_MAX) or (sub_mb_type[mbPartIdx] != B_DIRECT_8x8),
			/* SubMbPredMode( sub_mb_type[ mbPartIdx ] ) != Pred_L0 )*/
			SubMbPredMode(sub_mb_type[mbPartIdx]) != PRED_L0,

			mbPartIdx < 4
		do
			mbPartIdx := mbPartIdx + 1;
		end


	CheckmbPartIdx: action
				==>
		guard
			mbPartIdx < 4
		do
			subMbPartIdx    := 0;
			subMbPartIdxMax := NumSubMbPart(mb_type,sub_mb_type[mbPartIdx]);
			mbPartIdx       := mbPartIdx + 1;
		end

/*
if( sub_mb_type[ mbPartIdx ] != B_Direct_8x8 &&
    SubMbPredMode( sub_mb_type[ mbPartIdx ] ) != Pred_L1 )
*/
	ReadMvdl0Asked.Launch: action
				==>
			//             mvd_l0
			TypeOfVLD    :[  VLD_SE ,  VLD_SE  ]
		guard
			   not(mb_type >= BLOCK_TYPE_B_MIN and mb_type <= BLOCK_TYPE_B_MAX)
			or    (sub_mb_type[mbPartIdx - 1] != B_DIRECT_8x8),
			SubMbPredMode(sub_mb_type[mbPartIdx - 1]) != PRED_L1,
			subMbPartIdx < subMbPartIdxMax
		do
			subMbPartIdx := subMbPartIdx +1;
		end

	ReadMvdl0Asked.Skip: action
				==>
		guard
			   (mb_type >= BLOCK_TYPE_B_MIN and mb_type <= BLOCK_TYPE_B_MAX and sub_mb_type[mbPartIdx - 1] = B_DIRECT_8x8)
			or SubMbPredMode(sub_mb_type[mbPartIdx - 1]) = PRED_L1,
			subMbPartIdx < subMbPartIdxMax
		do
			subMbPartIdx := subMbPartIdx +1;
		end

/*
if( sub_mb_type[ mbPartIdx ] != B_Direct_8x8 &&
    SubMbPredMode( sub_mb_type[ mbPartIdx ] ) != Pred_L0 )
*/
	ReadMvdl1Asked.Launch: action
				==>
			//             mvd_l0
			TypeOfVLD    :[  VLD_SE ,  VLD_SE  ]
		guard
			not(mb_type >= BLOCK_TYPE_B_MIN and mb_type <= BLOCK_TYPE_B_MAX) or (sub_mb_type[mbPartIdx - 1] != B_DIRECT_8x8),
			SubMbPredMode(sub_mb_type[mbPartIdx - 1]) != PRED_L0,
			subMbPartIdx < subMbPartIdxMax
		do
			subMbPartIdx := subMbPartIdx +1;
		end

	ReadMvdl1Asked.Skip: action
				==>
		guard
			   (mb_type >= BLOCK_TYPE_B_MIN and mb_type <= BLOCK_TYPE_B_MAX and sub_mb_type[mbPartIdx - 1] = B_DIRECT_8x8)
			or SubMbPredMode(sub_mb_type[mbPartIdx - 1]) != PRED_L0,
			subMbPartIdx < subMbPartIdxMax
		do
			subMbPartIdx := subMbPartIdx +1;
		end

	ReadRefIdxLX: action
			ValVLD :[ValueOfVLD] repeat 8
				==>
		do
			foreach int i in 0 .. 3
			do
				ref_idx_l0[i] := ValueOfVLD[i];
				ref_idx_l1[i] := ValueOfVLD[i+4];
				if(DEBUG_MV)then
						println("refidxl1["+i+"] :"+ValueOfVLD[i+4]);
						println("refidxl0["+i+"] :"+ValueOfVLD[i]);
				end
			end
		end

	HasMvdl0: action ==>
		guard
			//Fix me : should be SubMbPredMode(mb_type,sub_mb_type)& PRED_L0 != 0
			not(mb_type >= BLOCK_TYPE_B_MIN and mb_type <= BLOCK_TYPE_B_MAX) or (sub_mb_type[mbPartIdx - 1] != B_DIRECT_8x8),
			SubMbPredMode(sub_mb_type[mbPartIdx - 1]) != PRED_L1
		end

	HasNotMvdl0: action ==>
		guard
			//Fix me : should be SubMbPredMode(mb_type,sub_mb_type)& PRED_L0 = 0
			mb_type >= BLOCK_TYPE_B_MIN and mb_type <= BLOCK_TYPE_B_MAX and sub_mb_type[mbPartIdx - 1] = B_DIRECT_8x8
			or SubMbPredMode(sub_mb_type[mbPartIdx - 1]) = PRED_L1
		end

	ReadMvdl0.Launch: action
			ValVLD   :[ValueOfVLD] repeat 2
				==>
			RefIdxL0     :[ref_idx_l0[mbPartIdx-1]],
			MvResl0      :[ValueOfVLD] repeat 2
		guard
			subMbPartIdx < subMbPartIdxMax
		do
			if(DEBUG_MV)then
				println("sub_mb_pred mvld0["+ (mbPartIdx - 1) +"]["+subMbPartIdx+"][0]:"+ValueOfVLD[0]);
				println("sub_mb_pred mvld0["+ (mbPartIdx - 1) +"]["+subMbPartIdx+"][1]:"+ValueOfVLD[1]);
			end
			subMbPartIdx := subMbPartIdx +1;
		end

	ReadMvdlX_Done: action ==>
		guard
			subMbPartIdx = subMbPartIdxMax
		end


	HasMvdl1: action ==>
		guard
			//Fix me : should be SubMbPredMode(mb_type,sub_mb_type)& PRED_L1 != 0
			mb_type >= BLOCK_TYPE_B_MIN,
			mb_type <= BLOCK_TYPE_B_MAX,
			sub_mb_type[mbPartIdx - 1] != B_DIRECT_8x8,
			SubMbPredMode(sub_mb_type[mbPartIdx - 1]) != PRED_L0
		end

	HasNotMvdl1: action ==>
		guard
			//Fix me : should be SubMbPredMode(mb_type,sub_mb_type)& PRED_L1 = 0
			mb_type < BLOCK_TYPE_B_MIN
			or mb_type > BLOCK_TYPE_B_MAX
			or sub_mb_type[mbPartIdx - 1] = B_DIRECT_8x8
			or SubMbPredMode(sub_mb_type[mbPartIdx - 1]) = PRED_L0
		end

	ReadMvdl1.Launch: action
			ValVLD :[ValueOfVLD] repeat 2
				==>
			MvResl1      :[ValueOfVLD] repeat 2,
			RefIdxL1 :[ref_idx_l1[mbPartIdx-1]]
		guard
			subMbPartIdx < subMbPartIdxMax
		do
			if(DEBUG_MV)then
				println("mvld1["+ (mbPartIdx - 1) +"]["+subMbPartIdx+"][0]:"+ValueOfVLD[0]);
				println("mvld1["+ (mbPartIdx - 1) +"]["+subMbPartIdx+"][1]:"+ValueOfVLD[1]);
			end
			subMbPartIdx := subMbPartIdx +1;
		end

	SendEndSubMbPred: action
				==>
			TypeOfVLD   :[ SKIP_NAL ]
		end

	schedule fsm ReadSubMbTypeAsked:
		ReadSubMbTypeAsked (ReadSubMbType.Asked )--> ReadSubMbTypeDone;

		ReadSubMbTypeDone  (ReadSubMbType.Done  )--> ReadParameters;

		ReadParameters     (ReadParameters      )--> AskRefIdxL0;

		AskRefIdxL0        (AskRefIdxL0.Launch  )--> AskRefIdxL0;
		AskRefIdxL0        (AskRefIdxLX.Skip    )--> AskRefIdxL0;
		AskRefIdxL0        (SendOrReadDone      )--> AskRefIdxL1;

		AskRefIdxL1        (AskRefIdxL1.Launch  )--> AskRefIdxL1;
		AskRefIdxL1        (AskRefIdxLX.Skip    )--> AskRefIdxL1;
		AskRefIdxL1        (SendOrReadDone      )--> CheckmbPartIdx0;

		CheckmbPartIdx0    (CheckmbPartIdx      )--> ReadMvdl0Asked;

		ReadMvdl0Asked     (ReadMvdl0Asked      )--> ReadMvdl0Asked;
		ReadMvdl0Asked     (CheckmbPartIdx      )--> ReadMvdl0Asked;
		ReadMvdl0Asked     (SendOrReadDone      )--> CheckmbPartIdx1;

		CheckmbPartIdx1    (CheckmbPartIdx      )--> ReadMvdl1Asked;

		ReadMvdl1Asked     (ReadMvdl1Asked      )--> ReadMvdl1Asked;
		ReadMvdl1Asked     (CheckmbPartIdx      )--> ReadMvdl1Asked;
		ReadMvdl1Asked     (SendOrReadDone      )--> ReadRefIdxLX;

		ReadRefIdxLX       (ReadRefIdxLX        )--> CheckmbPartIdx2;

		CheckmbPartIdx2    (CheckmbPartIdx      )--> CheckReadMvdl0;

		CheckReadMvdl0     (HasMvdl0            )--> ReadMvdl0;
		CheckReadMvdl0     (HasNotMvdl0         )--> CheckMbPart4MvdL0;

		ReadMvdl0          (ReadMvdl0           )--> ReadMvdl0;
		ReadMvdl0          (ReadMvdlX_Done      )--> CheckMbPart4MvdL0;

		CheckMbPart4MvdL0  (CheckmbPartIdx      )--> CheckReadMvdl0;
		CheckMbPart4MvdL0  (SendOrReadDone      )--> CheckmbPartIdx3;

		CheckmbPartIdx3    (CheckmbPartIdx      )--> CheckReadMvdl1;

		CheckReadMvdl1     (HasMvdl1            )--> ReadMvdl1;
		CheckReadMvdl1     (HasNotMvdl1         )--> CheckMbPart4MvdL1;

		ReadMvdl1          (ReadMvdl1           )--> ReadMvdl1;
		ReadMvdl1          (ReadMvdlX_Done      )--> CheckMbPart4MvdL1;

		CheckMbPart4MvdL1  (CheckmbPartIdx      )--> CheckReadMvdl1;
		CheckMbPart4MvdL1  (SendOrReadDone      )--> SendEndSubMbPred;

		SendEndSubMbPred   (SendEndSubMbPred    )--> ReadSubMbTypeAsked;
	end
	priority
		AskRefIdxL0.Launch   > AskRefIdxLX.Skip;
		AskRefIdxLX.Skip     > SendOrReadDone;
		AskRefIdxL1.Launch   > AskRefIdxLX.Skip;
		CheckmbPartIdx       > SendOrReadDone;
		ReadMvdl0Asked       > CheckmbPartIdx;
		ReadMvdl1Asked       > CheckmbPartIdx;
		ReadMvdl0            > ReadMvdlX_Done;
	end
end
