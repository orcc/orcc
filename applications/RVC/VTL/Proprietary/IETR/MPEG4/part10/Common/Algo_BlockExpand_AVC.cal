/********************************************************************************

This software module was originally developed by 
Damien de Saint Jorre (IETR/INSA of Rennes), 
in the course of development of the ISO/IEC 23002-4 (Video Tool Library) 
for reference purposes and its performance may not have been optimized. 
This software module is an implementation of one or more tools as 
specified by the ISO/IEC 23002-4.

ISO/IEC gives You a royalty-free, worldwide, non-exclusive, copyright 
license to copy, distribute, and make derivative works of this software 
module or modifications thereof for use in implementations of the 
ISO/IEC 23002-4 in products that satisfy conformance criteria (if any). 

Those intending to use this software module in products are advised that 
its use may infringe existing patents. ISO/IEC have no liability for use 
of this software module or modifications thereof.

Copyright is not released for products that do not conform to audiovisual 
and image-coding related ITU Recommendations and/or ISO/IEC International 
Standards. 

Assurance that the originally developed software module can be used 
(1) in the ISO/IEC 23002-4 once the ISO/IEC 23002-4 has been adopted; and 
(2) to develop the ISO/IEC 23002-4: 

IETR/INSA of Rennes grants ISO/IEC all rights necessary to 
include the originally developed software module or modifications thereof 
in the ISO/IEC 23002-4 and to permit ISO/IEC to offer You a royalty-free, 
worldwide, non-exclusive, copyright license to copy, distribute, and make 
derivative works for use in implementations of the ISO/IEC 23002-4 in 
products that satisfy conformance criteria (if any), and to the extent 
that such originally developed software module or portions of it are 
included in the ISO/IEC 23002-4.  To the extent that IETR/INSA of Rennes
owns patent rights that would be required to make, use, or 
sell the originally developed software module or portions thereof 
included in the ISO/IEC 23002-4 in a conforming product, IETR/INSA of
Rennes will assure the ISO/IEC that it is willing to 
negotiate licenses under reasonable and non-discriminatory terms and 
conditions with applicants throughout the world.

ISO/IEC gives You a free license to this software module or modifications 
thereof for the sole  purpose of developing theISO/IEC 23002-4

IETR/INSA of Rennes retains full right to modify and use the 
code for its own purpose, assign or donate the code to a third party and 
to inhibit third parties from using the code for products that do not 
conform to MPEG-related ITU Recommendations and/or ISO/IEC International 
Standards. 

This copyright notice must be included in all copies or derivative works. 
Copyright (c) ISO/IEC 2008.

*****************************************************************************/
//Modified by Damien de Saint Jorre (IETR/INSA of Rennes)
package Proprietary.IETR.MPEG4.part10.Common;

import MPEG.MPEG4.part10.Common.Imp_MacroBlockInfo.*;

actor Algo_BlockExpand_AVC ()
	uint(size=6)  MbType,
	int (size=12) Value,
	uint(size=4)  Run,
	bool          Last
		==> 
	int(size=12) Coeff
		:

	/* Constants */
	uint(size=2) BLOCK_4x4   = 0;
//	uint(size=2) BLOCK_8x8   = 1;
	uint(size=2) BLOCK_16x16 = 2;

	uint(size=2)  Y_COMPONENT = 0;
	uint(size=2)  U_COMPONENT = 1;
	uint(size=2)  V_COMPONENT = 2;

	int (size=5) SZ_LUMA_DC_16X16 = 16;
	int (size=5) SZ_LUMA_AC_16X16 = 16;
	int (size=5) SZ_LUMA_AC_4X4   = 16;
	int (size=5) SZ_CHROMA_DC     = 4;
	int (size=5) SZ_CHROMA_AC     = 16;

	/* State Variable */
	List(type:int(size=12), size=16) ValCoeff := [ 0 : for int i in 0 .. 15];
	uint(size=5) IdxValCoeff      := 0;

	uint(size=8) LumaMBSize;
	uint(size=2) Component        := Y_COMPONENT;
	bool         DC_ComponentSent := false;
	uint(size=5) NbBlocksSent     := 0;



	/* Actions */

	SkipBlock: action
			MbType :[mb_type]
				==>
		guard
			mb_type = BLOCK_TYPE_I_PCM
		end

	ReadBlockSize: action
			MbType :[mb_type]
				==>
		guard
			mb_type != BLOCK_TYPE_I_PCM
		do
			LumaMBSize       :=
				if(Is_Intra_16x16(mb_type))then
					BLOCK_16x16
				else
					BLOCK_4x4
				end;
			NbBlocksSent     := 0;
			DC_ComponentSent := false;
		end


	NoLast: action
			Last  :[ValLast],
			Run   :[ValRun],
			Value :[Val]
				==>
		guard
			ValLast = false
		do
			ValCoeff[IdxValCoeff] := Val;
			IdxValCoeff           := IdxValCoeff + 1;
			if (ValRun > 0) then
				foreach int j in 0 .. ValRun - 1
				do
					ValCoeff[IdxValCoeff + j] := 0;
				end
				IdxValCoeff           := IdxValCoeff + ValRun;
			end
		end


	Last_equaltrue: action
			Last :[ValLast]
				==>
		guard
			ValLast = true
		var
			int(size=12) buff
		do
			if(IdxValCoeff > 0) then
				foreach int j in 0 .. (IdxValCoeff -1)/2
				do
					buff                      := ValCoeff[j];
					ValCoeff[j]               := ValCoeff[IdxValCoeff - 1 - j];
					ValCoeff[IdxValCoeff - 1 - j] := buff;
				end
			end
		end


		/************ Send Luma DC Component (16x16) ************/
	isLumaDC_16x16: action ==>
		guard
			Component        = Y_COMPONENT,
			DC_ComponentSent = false,
			LumaMBSize       = BLOCK_16x16
		do	
			foreach int j in IdxValCoeff .. SZ_LUMA_DC_16X16 - 1
			do
				ValCoeff[j] := 0;
			end
			IdxValCoeff := 0;
		end


	SendLumaDC_16x16: action
				==>
			Coeff :[ValCoeff] repeat SZ_LUMA_DC_16X16
		do
			DC_ComponentSent := true;
		end


		/************ Send Luma AC Component (16x16) ************/
	isLumaAC_16x16: action ==>
		guard
			Component        = Y_COMPONENT,
			DC_ComponentSent = true,
			LumaMBSize       = BLOCK_16x16
		do
			foreach int j in IdxValCoeff .. SZ_LUMA_AC_16X16 - 1
			do
				ValCoeff[j] := 0;
			end
			IdxValCoeff := 0;	
		end


	SendLumaAC_16x16.Launch: action
				==>
			Coeff :[ValCoeff] repeat SZ_LUMA_AC_16X16
		guard
			NbBlocksSent     < 15
		do
			NbBlocksSent := NbBlocksSent + 1;
		end	


	SendLumaAC_16x16.LastBlock: action
				==>
			Coeff :[ValCoeff] repeat SZ_LUMA_AC_16X16
		do
			NbBlocksSent     := 0;
			Component        := U_COMPONENT;	
			DC_ComponentSent := false;
		end	


		/************ Send Luma AC Component (4x4) ************/
	isLumaAC_4x4: action ==>
		guard
			Component   = Y_COMPONENT,
			LumaMBSize != BLOCK_16x16
		do
			foreach int j in IdxValCoeff .. SZ_LUMA_AC_4X4 - 1
			do
				ValCoeff[j] := 0;
			end
			IdxValCoeff := 0;	
		end


	SendLumaAC_4x4.Launch: action
				==>
			Coeff :[ValCoeff] repeat SZ_LUMA_AC_4X4
		guard
			NbBlocksSent     < 15
		do
			NbBlocksSent := NbBlocksSent + 1;
		end


	SendLumaAC_4x4.LastBlock: action
				==>
			Coeff :[ValCoeff] repeat SZ_LUMA_AC_4X4
		do	
			Component        := U_COMPONENT;
			NbBlocksSent     := 0;
		end


		/************ Send Chroma DC Component ************/
	isChromaDC: action ==>
		guard
			Component        != Y_COMPONENT,
			DC_ComponentSent  = false
		do
			foreach int j in IdxValCoeff .. SZ_CHROMA_DC - 1
			do
				ValCoeff[j] := 0;
			end
			IdxValCoeff := 0;	
		end


	SendChromaDC: action
				==>
			Coeff :[ValCoeff] repeat SZ_CHROMA_DC
		do	
			if(Component = U_COMPONENT) then
				Component := V_COMPONENT;
			else
				Component := U_COMPONENT;	
				DC_ComponentSent := true;	
			end
		end


		/************ Send Chroma AC Component (4x4) ************/
	isChromaAC: action ==>
		guard
			Component        != Y_COMPONENT,
			DC_ComponentSent  = true
		do	
			foreach int j in IdxValCoeff .. SZ_CHROMA_AC - 1
			do
				ValCoeff[j] := 0;
			end
			IdxValCoeff := 0;	
		end


	SendChromaAC.Launch: action
				==>
			Coeff :[ValCoeff] repeat SZ_CHROMA_AC
		guard
			NbBlocksSent     < 3
		do
			NbBlocksSent := NbBlocksSent + 1;
		end


	SendChromaAC.LastBlock_UComponent: action
				==>
			Coeff :[ValCoeff] repeat SZ_CHROMA_AC
		guard
			Component = U_COMPONENT
		do	
			Component        := V_COMPONENT;
			NbBlocksSent     := 0;
		end


	SendChromaAC.LastBlock_VComponent: action
				==>
			Coeff :[ValCoeff] repeat SZ_CHROMA_AC
		do	
			Component        := Y_COMPONENT;
			NbBlocksSent     := 0;
			DC_ComponentSent := false;
		end

	/* Scheduler */

	schedule fsm ReadBlockSize:

		ReadBlockSize    ( ReadBlockSize                     )--> ReadData;
		ReadBlockSize    ( SkipBlock                         )--> ReadBlockSize;

		ReadData         ( NoLast                            )--> ReadData;
		ReadData         ( Last_equaltrue                    )--> ChooseSizeData;

		ChooseSizeData   ( isLumaDC_16x16                    )--> SendLumaDC_16x16;
		SendLumaDC_16x16 ( SendLumaDC_16x16                  )--> ReadData;

		ChooseSizeData   ( isLumaAC_16x16                    )--> SendLumaAC_16x16;
		SendLumaAC_16x16 ( SendLumaAC_16x16                  )--> ReadData;

		ChooseSizeData   ( isLumaAC_4x4                      )--> SendLuma_4x4;
		SendLuma_4x4     ( SendLumaAC_4x4                    )--> ReadData;

		ChooseSizeData   ( isChromaDC                        )--> SendChromaDC;
		SendChromaDC     ( SendChromaDC                      )--> ReadData;

		ChooseSizeData   ( isChromaAC                        )--> SendChromaAC;
		SendChromaAC     ( SendChromaAC.Launch               )--> ReadData;
		SendChromaAC     ( SendChromaAC.LastBlock_UComponent )--> ReadData;
		SendChromaAC     ( SendChromaAC.LastBlock_VComponent )--> ReadBlockSize;
	end

	priority
		NoLast                  > Last_equaltrue;
		SendLumaAC_16x16.Launch > SendLumaAC_16x16.LastBlock;
		SendLumaAC_4x4.Launch   > SendLumaAC_4x4.LastBlock;
		SendChromaAC.Launch     > SendChromaAC.LastBlock_UComponent > SendChromaAC.LastBlock_VComponent;
		isLumaAC_4x4            > isLumaAC_16x16                    > isChromaAC;
		isChromaAC              > isChromaDC                        > isLumaDC_16x16;
	end
end