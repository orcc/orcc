/********************************************************************************

This software module was originally developed by 
Damien de Saint Jorre (IETR/INSA of Rennes), 
in the course of development of the ISO/IEC 23002-4 (Video Tool Library) 
for reference purposes and its performance may not have been optimized. 
This software module is an implementation of one or more tools as 
specified by the ISO/IEC 23002-4.

ISO/IEC gives You a royalty-free, worldwide, non-exclusive, copyright 
license to copy, distribute, and make derivative works of this software 
module or modifications thereof for use in implementations of the 
ISO/IEC 23002-4 in products that satisfy conformance criteria (if any). 

Those intending to use this software module in products are advised that 
its use may infringe existing patents. ISO/IEC have no liability for use 
of this software module or modifications thereof.

Copyright is not released for products that do not conform to audiovisual 
and image-coding related ITU Recommendations and/or ISO/IEC International 
Standards. 

Assurance that the originally developed software module can be used 
(1) in the ISO/IEC 23002-4 once the ISO/IEC 23002-4 has been adopted; and 
(2) to develop the ISO/IEC 23002-4: 

IETR/INSA of Rennes grants ISO/IEC all rights necessary to 
include the originally developed software module or modifications thereof 
in the ISO/IEC 23002-4 and to permit ISO/IEC to offer You a royalty-free, 
worldwide, non-exclusive, copyright license to copy, distribute, and make 
derivative works for use in implementations of the ISO/IEC 23002-4 in 
products that satisfy conformance criteria (if any), and to the extent 
that such originally developed software module or portions of it are 
included in the ISO/IEC 23002-4.  To the extent that IETR/INSA of Rennes
owns patent rights that would be required to make, use, or 
sell the originally developed software module or portions thereof 
included in the ISO/IEC 23002-4 in a conforming product, IETR/INSA of
Rennes will assure the ISO/IEC that it is willing to 
negotiate licenses under reasonable and non-discriminatory terms and 
conditions with applicants throughout the world.

ISO/IEC gives You a free license to this software module or modifications 
thereof for the sole  purpose of developing theISO/IEC 23002-4

IETR/INSA of Rennes retains full right to modify and use the 
code for its own purpose, assign or donate the code to a third party and 
to inhibit third parties from using the code for products that do not 
conform to MPEG-related ITU Recommendations and/or ISO/IEC International 
Standards. 

This copyright notice must be included in all copies or derivative works. 
Copyright (c) ISO/IEC 2008.
*****************************************************************************/
package Proprietary.IETR.MPEG4.part10.Frext;

import MPEG.MPEG4.part10.Common.Imp_MacroBlockInfo.*;
import MPEG.Common.Imp_PictureInfo.*;

actor Algo_MvBuffer()
	uint(size=6)  MbType,
	uint(size=4)  SubMbType,

	bool          NewPic,

	uint(size=32) Poc,
	bool          Direct8x8Inference,

	uint(size=13) CurrMbAddr,
	uint(size=7)  PicWidthInMb,

	bool          DirectPredL0,
	bool          DirectPredL1,
	uint(size=4)  RefIdxL0,
	uint(size=4)  RefIdxL1,
	int (size=16) MvL0,
	int (size=16) MvL1,

	bool          Empty_DPB,
	int (size=32) DelList,
	int (size=32) LongTermList,

	int (size=32) RefList1
		==>
	bool colZeroFlag
		:

	int (size=32) SENT_DONE = -2;

	uint(size=4) B_DIRECT_8x8 = 0;

	List(type: List(type: List(type: int(size=5), size=MAX_PICHEIGHT_PX/4), size=MAX_PICWIDTH_PX/4), size=16) ListRefIdxL0;
	List(type: List(type: List(type: int(size=5), size=MAX_PICHEIGHT_PX/4), size=MAX_PICWIDTH_PX/4), size=16) ListRefIdxL1;
	List(type: List(type: List(type: List(type: int(size=5), size=2), size=MAX_PICHEIGHT_PX/4), size=MAX_PICWIDTH_PX/4), size=16) ListMvL0;
	List(type: List(type: List(type: List(type: int(size=5), size=2), size=MAX_PICHEIGHT_PX/4), size=MAX_PICWIDTH_PX/4), size=16) ListMvL1;
	List(type: bool,          size=16) IsReference;
	List(type: uint(size=32), size=16) ListPoc;

	uint(size=3)  MbPartIdxMax;
	uint(size=3)  MbPartIdx;
	uint(size=3)  SizeMbMv;
	uint(size=3)  SubMbPartIdxMax;
	uint(size=3)  SubMbPartIdx;
	uint(size=3)  SizeSubMbMv;
	uint(size=1)  Idx_Sub_Tab;
	uint(size=6)  mb_type;
	uint(size=6)  sub_mb_type;
	bool          IsPredL0;
	bool          IsPredL1;
	uint(size=5)  Size_RefList;
	uint(size=5)  Idx_RefList;
	uint(size=5)  WriteListIdx;
	uint(size=5)  ReadListIdx;
	bool          colPic_IsShortTermRef;
	uint(size=32) Mbx;
	uint(size=32) Mby;
	bool          direct_8x8_inference_flag;

	uint(size=4) NbPartitionsToWrite;
	List(type: uint(size=32), size=16) Partition_Mbx;
	List(type: uint(size=32), size=16) Partition_Mby;

	GetNewPic: action
			NewPic             :[IsNewPic],
			Poc                :[Picture_Order_Count],
			Direct8x8Inference :[Direct8x8InferFlag]
				==>
		guard
			IsNewPic
		var
			bool EndLoop//Delete me when the bug in Orcc will be solved
		do
			WriteListIdx := 0;
			EndLoop := IsReference[0];
			while( EndLoop /*IsReference[WriteListIdx]*/ and WriteListIdx < 15)
			do
				WriteListIdx := WriteListIdx + 1;
				EndLoop := IsReference[WriteListIdx];
			end
			IsReference[WriteListIdx] := true;
			ListPoc    [WriteListIdx] := Picture_Order_Count;
			direct_8x8_inference_flag := Direct8x8InferFlag;
		end

	GetMbType.MacroBlkIorSI: action
			MbType :[MacroBlkType],
			NewPic  :[IsNewPic]
				==>
		guard
			MacroBlkType >= BLOCK_TYPE_INTRA_MIN and MacroBlkType <= BLOCK_TYPE_INTRA_MAX,
			not IsNewPic
		end

	EatTokens: action
			CurrMbAddr     :[Mb_Addr],
			PicWidthInMb   :[pic_width]
				==>
		do
			Mbx := Mb_Addr mod pic_width;
			Mby := Mb_Addr  /  pic_width;
			//There are 16 Partitions in a macroblock
			Mbx := Mbx * 4;
			Mby := Mby * 4;
			foreach int i in Mbx .. Mbx + 3
			do
				foreach int j in Mby .. Mby + 3
				do
					ListRefIdxL0[WriteListIdx][i][j]    := -1;
					ListRefIdxL1[WriteListIdx][i][j]    := -1;
					ListMvL0    [WriteListIdx][i][j][0] :=  0;
					ListMvL0    [WriteListIdx][i][j][1] :=  0;
					ListMvL1    [WriteListIdx][i][j][0] :=  0;
					ListMvL1    [WriteListIdx][i][j][1] :=  0;
				end
			end
		end

	function GetDirect8x8InfIdx(uint Idx)
				-->
			uint
		:
			//XXXXXX00 -> XXXXXX00
			//XXXXXX01 -> XXXXXX00
			//XXXXXX10 -> XXXXXX11
			//XXXXXX11 -> XXXXXX11
			(Idx & 0xFFFFFFFE) + ((Idx >> 1)&1)
		end

	function Compute_ColZero(uint Idx_x, uint Idx_y)
				-->
			bool
		var
			uint Idx_x_Infer =
				if(direct_8x8_inference_flag)then
					GetDirect8x8InfIdx(Idx_x)
				else
					Idx_x
				end,
			uint Idx_y_Infer =
				if(direct_8x8_inference_flag)then
					GetDirect8x8InfIdx(Idx_y)
				else
					Idx_y
				end
		:
			if(not colPic_IsShortTermRef)then
				false
			else
				if(ListRefIdxL0[ReadListIdx][Idx_x_Infer][Idx_y_Infer] = -1 and ListRefIdxL1[ReadListIdx][Idx_x_Infer][Idx_y_Infer] = -1)then
					false
				else
					if(ListRefIdxL0[ReadListIdx][Idx_x_Infer][Idx_y_Infer] != -1)then
						if(     ListRefIdxL0[ReadListIdx][Idx_x_Infer][Idx_y_Infer]     =  0
						    and ListMvL0    [ReadListIdx][Idx_x_Infer][Idx_y_Infer][0] >= -1
						    and ListMvL0    [ReadListIdx][Idx_x_Infer][Idx_y_Infer][0] <=  1
						    and ListMvL0    [ReadListIdx][Idx_x_Infer][Idx_y_Infer][1] >= -1
						    and ListMvL0    [ReadListIdx][Idx_x_Infer][Idx_y_Infer][1] <=  1)then
							true
						else
							false
						end
					else
						if(     ListRefIdxL1[ReadListIdx][Idx_x_Infer][Idx_y_Infer]     =  0
						    and ListMvL1    [ReadListIdx][Idx_x_Infer][Idx_y_Infer][0] >= -1
						    and ListMvL1    [ReadListIdx][Idx_x_Infer][Idx_y_Infer][0] <=  1
						    and ListMvL1    [ReadListIdx][Idx_x_Infer][Idx_y_Infer][1] >= -1
						    and ListMvL1    [ReadListIdx][Idx_x_Infer][Idx_y_Infer][1] <=  1)then
							true
						else
							false
						end
					end
				end
			end
		end

	GetMbType.B_Skip_B_Direct_16x16: action
			MbType       :[MacroBlkType],
			NewPic       :[IsNewPic],
			CurrMbAddr   :[Curr_Mb_Addr],
			PicWidthInMb :[PicWidth]
				==>
			colZeroFlag  :[IsColZero] repeat 4
		guard
			MacroBlkType = BLOCK_TYPE_B_SKIP or MacroBlkType = BLOCK_TYPE_B_DIRECT_16x16,
			not IsNewPic
		var
			List(type: bool, size=4) IsColZero
		do
			mb_type      := MacroBlkType;
			MbPartIdx    := 0;
			MbPartIdxMax := 16;
			SizeMbMv     := SZ_4x4;
			Mbx := Curr_Mb_Addr mod PicWidth;
			Mby := Curr_Mb_Addr  /  PicWidth;
			//There are 16 Partitions in a macroblock
			Mbx := Mbx * 4;
			Mby := Mby * 4;
			foreach int j in 0 .. 1
			do
				foreach int i in 0 .. 1
				do
					IsColZero[2*j+i] := Compute_ColZero(Mbx+2*i,Mby+2*j);
				end
			end
		end

	GetMbType.Others: action
			MbType       :[MacroBlkType],
			NewPic       :[IsNewPic],
			CurrMbAddr   :[Curr_Mb_Addr],
			PicWidthInMb :[PicWidth]
				==>
		guard
			not(MacroBlkType >= BLOCK_TYPE_INTRA_MIN and MacroBlkType <= BLOCK_TYPE_INTRA_MAX),
			MacroBlkType != BLOCK_TYPE_B_SKIP,
			MacroBlkType != BLOCK_TYPE_B_DIRECT_16x16,
			not IsNewPic
		do
			mb_type      := MacroBlkType;
			MbPartIdx    := 0;
			MbPartIdxMax := NumMbPart(MacroBlkType);
			SizeMbMv     := SizeMbPart(MacroBlkType);
			Idx_Sub_Tab  :=
				if(MacroBlkType >= BLOCK_TYPE_B_MIN and MacroBlkType <= BLOCK_TYPE_B_MAX) then
					0
				else
					1
				end;
			Mbx := Curr_Mb_Addr mod PicWidth;
			Mby := Curr_Mb_Addr  /  PicWidth;
			//There are 16 Partitions in a macroblock
			Mbx := Mbx * 4;
			Mby := Mby * 4;
		end

	GetMbParameters.Block16x16: action
				==>
		guard
			MbPartIdx < MbPartIdxMax,
			SizeMbMv  = SZ_16x16
		var
			uint(size=4) Idx := 0
		do
			NbPartitionsToWrite := 16;
			foreach int i in Mbx .. Mbx + 3
			do
				foreach int j in Mby .. Mby + 3
				do
					Partition_Mbx[Idx] := i;
					Partition_Mby[Idx] := j;
					Idx                := Idx + 1;
				end
			end
			IsPredL0  := Mb_Is_PredL0(mb_type, MbPartIdx);
			IsPredL1  := Mb_Is_PredL1(mb_type, MbPartIdx);
			MbPartIdx := MbPartIdx + 1;
		end

	GetMbParameters.Block16x8: action
				==>
		guard
			MbPartIdx < MbPartIdxMax,
			SizeMbMv  = SZ_16x8
		var
			uint(size=4) Idx := 0
		do
			NbPartitionsToWrite := 8;
			foreach int i in Mbx .. Mbx + 3
			do
				foreach int j in Mby + 2* (MbPartIdx&1) .. Mby + 2* (MbPartIdx&1) + 1
				do
					Partition_Mbx[Idx] := i;
					Partition_Mby[Idx] := j;
					Idx                := Idx + 1;
				end
			end
			IsPredL0  := Mb_Is_PredL0(mb_type, MbPartIdx);
			IsPredL1  := Mb_Is_PredL1(mb_type, MbPartIdx);
			MbPartIdx := MbPartIdx + 1;
		end

	GetMbParameters.Block8x16: action
				==>
		guard
			MbPartIdx < MbPartIdxMax,
			SizeMbMv  = SZ_8x16
		var
			uint(size=4) Idx := 0
		do
			NbPartitionsToWrite := 8;
			foreach int i in Mbx + 2* (MbPartIdx&1) .. Mbx + 2* (MbPartIdx&1) + 1
			do
				foreach int j in Mby .. Mby + 3
				do
					Partition_Mbx[Idx] := i;
					Partition_Mby[Idx] := j;
					Idx                := Idx + 1;
				end
			end
			IsPredL0  := Mb_Is_PredL0(mb_type, MbPartIdx);
			IsPredL1  := Mb_Is_PredL1(mb_type, MbPartIdx);
			MbPartIdx := MbPartIdx + 1;
		end

	GetMbParameters.Launch_B_Direct: action
				==>
		guard
			MbPartIdx < MbPartIdxMax,
			   mb_type = BLOCK_TYPE_B_SKIP
			or mb_type = BLOCK_TYPE_B_DIRECT_16x16
		var
			uint(size=3) localMbPartIdx    = MbPartIdx  /  4,
			uint(size=3) localSubMbPartIdx = MbPartIdx mod 4
		do
			NbPartitionsToWrite := 1;
			Partition_Mbx[0]    := Mbx + 2* (localMbPartIdx&1)      + (localSubMbPartIdx&1);
			Partition_Mby[0]    := Mby + 2* ((localMbPartIdx>>1)&1) + ((localSubMbPartIdx>>1)&1);
			IsPredL0  := false;
			IsPredL1  := false;
			MbPartIdx := MbPartIdx + 1;
		end

	LaunchGetSubMbParameters: action
			SubMbType :[ValSubMbType]
				==>
		guard
			MbPartIdx  < MbPartIdxMax,
			SizeMbMv   = SZ_8x8
		do
			SubMbPartIdx    :=  0;
			SubMbPartIdxMax :=  NumSubMbPart(mb_type,ValSubMbType);
			SizeSubMbMv     :=  SizeSubMbPart(mb_type,ValSubMbType);
			IsPredL0        := (SubMbPartPredMode[Idx_Sub_Tab][ValSubMbType & 15] & PRED_L0) != 0;
			IsPredL1        := (SubMbPartPredMode[Idx_Sub_Tab][ValSubMbType & 15] & PRED_L1) != 0;
			sub_mb_type     := ValSubMbType;
		end

	GetMbParametersFinished: action ==>
		guard
			MbPartIdx = MbPartIdxMax
		end

	GetSubMbParameters.Launch_B_Direct_8x8: action
				==>
			colZeroFlag  :[IsColZero]
		guard
			SubMbPartIdx < SubMbPartIdxMax,
			mb_type     = BLOCK_TYPE_B_8x8,
			sub_mb_type = B_DIRECT_8x8
		var
			bool         IsColZero
		do
			IsColZero := Compute_ColZero(Mbx + 2* (MbPartIdx&1) + (SubMbPartIdx&1) ,Mby + 2* ((MbPartIdx >>1)&1) +  ((SubMbPartIdx >>1)&1));
			NbPartitionsToWrite := 1;
			Partition_Mbx[0] := Mbx + 2* (MbPartIdx&1) + (SubMbPartIdx&1);
			Partition_Mby[0] := Mby + 2* ((MbPartIdx>>1)&1) +  ((SubMbPartIdx >>1)&1);
			SubMbPartIdx := SubMbPartIdx + 1;
		end

	GetSubMbParameters.Launch8x8: action
				==>
		guard
			SubMbPartIdx < SubMbPartIdxMax,
			SizeSubMbMv  = SZ_8x8,
			   mb_type     != BLOCK_TYPE_B_8x8
			or sub_mb_type != B_DIRECT_8x8
		var
			uint(size=4) Idx := 0
		do
			NbPartitionsToWrite := 4;
			foreach int i in Mbx + 2* (MbPartIdx&1) .. Mbx + 2* (MbPartIdx&1) + 1
			do
				foreach int j in Mby + 2* ((MbPartIdx>>1)&1) .. Mby + 2* ((MbPartIdx>>1)&1) + 1
				do
					Partition_Mbx[Idx] := i;
					Partition_Mby[Idx] := j;
					Idx                := Idx + 1;
				end
			end
			SubMbPartIdx := SubMbPartIdx + 1;
		end

	GetSubMbParameters.Launch8x4: action
				==>
		guard
			SubMbPartIdx < SubMbPartIdxMax,
			SizeSubMbMv  = SZ_8x4
		do
			NbPartitionsToWrite := 2;
			Partition_Mbx[0]    := Mbx + 2* (MbPartIdx&1);
			Partition_Mby[0]    := Mby + 2* ((MbPartIdx>>1)&1) + (SubMbPartIdx&1);
			Partition_Mbx[1]    := Mbx + 2* (MbPartIdx&1) + 1;
			Partition_Mby[1]    := Mby + 2* ((MbPartIdx>>1)&1) + (SubMbPartIdx&1);
			SubMbPartIdx := SubMbPartIdx + 1;
		end

	GetSubMbParameters.Launch4x8: action
				==>
		guard
			SubMbPartIdx < SubMbPartIdxMax,
			SizeSubMbMv  = SZ_4x8
		do
			NbPartitionsToWrite := 2;
			Partition_Mbx[0]    := Mbx + 2* (MbPartIdx&1) + (SubMbPartIdx&1);
			Partition_Mby[0]    := Mby + 2* ((MbPartIdx>>1)&1);
			Partition_Mbx[1]    := Mbx + 2* (MbPartIdx&1) + (SubMbPartIdx&1);
			Partition_Mby[1]    := Mby + 2* ((MbPartIdx>>1)&1) + 1;
			SubMbPartIdx := SubMbPartIdx + 1;
		end

	GetSubMbParameters.Launch4x4: action
				==>
		guard
			SubMbPartIdx < SubMbPartIdxMax,
			SizeSubMbMv  = SZ_4x4
		do
			NbPartitionsToWrite := 1;
			Partition_Mbx[0]    := Mbx + 2* (MbPartIdx&1)      + (SubMbPartIdx&1);
			Partition_Mby[0]    := Mby + 2* ((MbPartIdx>>1)&1) + ((SubMbPartIdx>>1)&1);
			SubMbPartIdx := SubMbPartIdx + 1;
		end

	GetSubMbParametersFinished: action ==>
		guard
			SubMbPartIdx = SubMbPartIdxMax
		do
			MbPartIdx := MbPartIdx + 1;
		end

	GetBlockInfo.IsPredL0: action
			MvL0     :[Mvx,Mvy],
			RefIdxL0 :[ref_idx]
				==>
		guard
			    IsPredL0,
			not IsPredL1
		do
			foreach int i in 0 .. NbPartitionsToWrite - 1
			do
				ListRefIdxL0[WriteListIdx][Partition_Mbx[i]][Partition_Mby[i]]     := ref_idx;
				ListRefIdxL1[WriteListIdx][Partition_Mbx[i]][Partition_Mby[i]]     := -1;
				ListMvL0    [WriteListIdx][Partition_Mbx[i]][Partition_Mby[i]][0]  :=  Mvx;
				ListMvL0    [WriteListIdx][Partition_Mbx[i]][Partition_Mby[i]][1]  :=  Mvy;
				ListMvL1    [WriteListIdx][Partition_Mbx[i]][Partition_Mby[i]][0]  :=  0;
				ListMvL1    [WriteListIdx][Partition_Mbx[i]][Partition_Mby[i]][1]  :=  0;
			end
		end

	GetBlockInfo.IsPredL1: action
			MvL1     :[Mvx,Mvy],
			RefIdxL1 :[ref_idx]
				==>
		guard
			not IsPredL0,
			    IsPredL1
		do
			foreach int i in 0 .. NbPartitionsToWrite - 1
			do
				ListRefIdxL0[WriteListIdx][Partition_Mbx[i]][Partition_Mby[i]]     := -1;
				ListRefIdxL1[WriteListIdx][Partition_Mbx[i]][Partition_Mby[i]]     := ref_idx;
				ListMvL0    [WriteListIdx][Partition_Mbx[i]][Partition_Mby[i]][0]  :=  0;
				ListMvL0    [WriteListIdx][Partition_Mbx[i]][Partition_Mby[i]][1]  :=  0;
				ListMvL1    [WriteListIdx][Partition_Mbx[i]][Partition_Mby[i]][0]  :=  Mvx;
				ListMvL1    [WriteListIdx][Partition_Mbx[i]][Partition_Mby[i]][1]  :=  Mvy;
			end
		end

	GetBlockInfo.BiPred: action
			RefIdxL0 :[ref_idx_l0],
			RefIdxL1 :[ref_idx_l1],
			MvL0     :[MvxL0,MvyL0],
			MvL1     :[MvxL1,MvyL1]
				==>
		guard
			IsPredL0,
			IsPredL1
		do
			foreach int i in 0 .. NbPartitionsToWrite - 1
			do
				ListRefIdxL0[WriteListIdx][Partition_Mbx[i]][Partition_Mby[i]]     := ref_idx_l0;
				ListRefIdxL1[WriteListIdx][Partition_Mbx[i]][Partition_Mby[i]]     := ref_idx_l1;
				ListMvL0    [WriteListIdx][Partition_Mbx[i]][Partition_Mby[i]][0]  :=  MvxL0;
				ListMvL0    [WriteListIdx][Partition_Mbx[i]][Partition_Mby[i]][1]  :=  MvyL0;
				ListMvL1    [WriteListIdx][Partition_Mbx[i]][Partition_Mby[i]][0]  :=  MvxL1;
				ListMvL1    [WriteListIdx][Partition_Mbx[i]][Partition_Mby[i]][1]  :=  MvyL1;
			end
		end

	GetBlockInfo.IsDirectOrB_Skip_PredL0: action
			RefIdxL0     :[ref_idx_l0],
			MvL0         :[MvxL0,MvyL0],
			DirectPredL0 :[IsDirectPredL0],
			DirectPredL1 :[IsDirectPredL1]
				==>
		guard
			not IsPredL0,
			not IsPredL1,
			IsDirectPredL0,
			not IsDirectPredL1
		do
			foreach int i in 0 .. NbPartitionsToWrite - 1
			do
				ListRefIdxL0[WriteListIdx][Partition_Mbx[i]][Partition_Mby[i]]     := ref_idx_l0;
				ListRefIdxL1[WriteListIdx][Partition_Mbx[i]][Partition_Mby[i]]     := -1;
				ListMvL0    [WriteListIdx][Partition_Mbx[i]][Partition_Mby[i]][0]  :=  MvxL0;
				ListMvL0    [WriteListIdx][Partition_Mbx[i]][Partition_Mby[i]][1]  :=  MvyL0;
				ListMvL1    [WriteListIdx][Partition_Mbx[i]][Partition_Mby[i]][0]  :=  0;
				ListMvL1    [WriteListIdx][Partition_Mbx[i]][Partition_Mby[i]][1]  :=  0;
			end
		end

	GetBlockInfo.IsDirectOrB_Skip_PredL1: action
			RefIdxL1     :[ref_idx_l1],
			MvL1         :[MvxL1,MvyL1],
			DirectPredL0 :[IsDirectPredL0],
			DirectPredL1 :[IsDirectPredL1]
				==>
		guard
			not IsPredL0,
			not IsPredL1,
			not IsDirectPredL0,
			IsDirectPredL1
		do
			foreach int i in 0 .. NbPartitionsToWrite - 1
			do
				ListRefIdxL0[WriteListIdx][Partition_Mbx[i]][Partition_Mby[i]]     := -1;
				ListRefIdxL1[WriteListIdx][Partition_Mbx[i]][Partition_Mby[i]]     := ref_idx_l1;
				ListMvL0    [WriteListIdx][Partition_Mbx[i]][Partition_Mby[i]][0]  :=  0;
				ListMvL0    [WriteListIdx][Partition_Mbx[i]][Partition_Mby[i]][1]  :=  0;
				ListMvL1    [WriteListIdx][Partition_Mbx[i]][Partition_Mby[i]][0]  :=  MvxL1;
				ListMvL1    [WriteListIdx][Partition_Mbx[i]][Partition_Mby[i]][1]  :=  MvyL1;
			end
		end

	GetBlockInfo.IsDirectOrB_Skip_BiPred: action
			RefIdxL0     :[ref_idx_l0],
			RefIdxL1     :[ref_idx_l1],
			MvL0         :[MvxL0,MvyL0],
			MvL1         :[MvxL1,MvyL1],
			DirectPredL0 :[IsDirectPredL0],
			DirectPredL1 :[IsDirectPredL1]
				==>
		guard
			not IsPredL0,
			not IsPredL1,
			       IsDirectPredL0 and     IsDirectPredL1
			or not IsDirectPredL0 and not IsDirectPredL1
		do
			foreach int i in 0 .. NbPartitionsToWrite - 1
			do
				ListRefIdxL0[WriteListIdx][Partition_Mbx[i]][Partition_Mby[i]]     := ref_idx_l0;
				ListRefIdxL1[WriteListIdx][Partition_Mbx[i]][Partition_Mby[i]]     := ref_idx_l1;
				ListMvL0    [WriteListIdx][Partition_Mbx[i]][Partition_Mby[i]][0]  :=  MvxL0;
				ListMvL0    [WriteListIdx][Partition_Mbx[i]][Partition_Mby[i]][1]  :=  MvyL0;
				ListMvL1    [WriteListIdx][Partition_Mbx[i]][Partition_Mby[i]][0]  :=  MvxL1;
				ListMvL1    [WriteListIdx][Partition_Mbx[i]][Partition_Mby[i]][1]  :=  MvyL1;
			end
		end

	ReadDelList.Launch: action
			DelList:[DelPoc , DelFrame]
				==>
		guard
			DelPoc != SENT_DONE
		do
			foreach int i in 0 .. 15
			do
				if(DelPoc = ListPoc[i])then
					IsReference[i] := false;
				end
			end
		end

	ReadDelList.Done: action
			DelList   :[DelVal],
			Empty_DPB :[EmptyList]
				==>
		guard
			DelVal = SENT_DONE
		do
			if(EmptyList)then
				foreach int i in 0 .. 15
				do
					if(i != WriteListIdx)then
						IsReference[i] := false;
					end
				end
			end
		end

	ReadSizeRefList: action
			RefList1 :[SizeRefList]
				==>
		do
			Size_RefList := SizeRefList;
			Idx_RefList  := 0;
		end

	ReadRefList.Launch: action
			RefList1 :[ValRefList]
				==>
		guard
			Idx_RefList < Size_RefList
		var
			bool IdxNotFound//Delete me when the bug in Orcc will be solved
		do
			if(Idx_RefList   = 0)then
				ReadListIdx := 0;
				IdxNotFound := (ListPoc[ReadListIdx] != ValRefList) or (not IsReference[ReadListIdx]);
				while(/*(ListPoc[ReadListIdx] != ValRefList) or (not IsReference[ReadListIdx])*/IdxNotFound and ReadListIdx < 15)
				do
					ReadListIdx := ReadListIdx + 1;
					IdxNotFound := (ListPoc[ReadListIdx] != ValRefList)  or (not IsReference[ReadListIdx]);
				end
			end
			Idx_RefList := Idx_RefList + 1;
		end

	ReadRefList.Done: action ==>
		guard
			Idx_RefList >= Size_RefList
		end

	ReadLTList: action
			LongTermList :[LTList] repeat 16
				==>
		do
			colPic_IsShortTermRef := true;
			foreach int i in 0 .. 15
			do
				if(LTList[i] = ListPoc[ReadListIdx])then
					colPic_IsShortTermRef := false;
				end
			end
		end

	schedule fsm GetNewPic:
		GetNewPic          (GetNewPic                       )--> ReadSizeRefList;

		ReadSizeRefList    (ReadSizeRefList                 )--> ReadRefList;

		ReadRefList        (ReadRefList.Launch              )--> ReadRefList;
		ReadRefList        (ReadRefList.Done                )--> ReadLTList;

		ReadLTList         (ReadLTList                      )--> GetMbType;

		GetMbType          (GetNewPic                       )--> ReadDelList;
		GetMbType          (GetMbType.MacroBlkIorSI         )--> EatTokens;
		GetMbType          (GetMbType.B_Skip_B_Direct_16x16 )--> GetMbParameters;
		GetMbType          (GetMbType.Others                )--> GetMbParameters;

		EatTokens          (EatTokens                       )--> GetMbType;

		GetMbParameters    (GetMbParameters                 )--> GetBlockInfo4Mb;
		GetMbParameters    (LaunchGetSubMbParameters        )--> GetSubMbParameters;
		GetMbParameters    (GetMbParametersFinished         )--> GetMbType;

		GetBlockInfo4Mb    (GetBlockInfo                    )--> GetMbParameters;

		GetSubMbParameters (GetSubMbParameters              )--> GetBlockInfo4SubMb;
		GetSubMbParameters (GetSubMbParametersFinished      )--> GetMbParameters;

		GetBlockInfo4SubMb (GetBlockInfo                    )--> GetSubMbParameters;

		ReadDelList        (ReadDelList.Launch              )--> ReadDelList;
		ReadDelList        (ReadDelList.Done                )--> ReadSizeRefList;
	end
end