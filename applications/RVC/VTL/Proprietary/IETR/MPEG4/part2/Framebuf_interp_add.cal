// Interpolation for motion compensation, frame buffer and add motion and texture to produce pixels
//
// Authors: Ghislain Roquier(ghislain.roquier@epfl.ch), Matthieu Wipliez <mwipliez@insa-rennes.fr>

package Proprietary.IETR.MPEG4.part2;

actor Framebuf_interp_add (// Command flags from parser
	int NEWVOP,
	int INTRA,
	int ACCODED) int(size=FLAG_SZ) halfpel, // from MPEG4_algo_Interpolation_halfpel
int(size=ADDR_SZ) RA, int(size=ADDR_SZ) WA, // from MPEG4_mgnt_Framebuf
int(size=PIX_SZ) TEX, int(size=BTYPE_SZ) BTYPE ==> // from MPEG4_algo_Add
int(size=PIX_SZ) VID :

// from MPEG4_algo_Add
	int ADDR_SZ = 24;

	int BTYPE_SZ = 12;

	// search window size (in macroblocks)
	int SEARCHWIN_IN_MB = 3;

	// maximum image width (in macroblocks)
	int MAXW_IN_MB = 121;

	// maximum image height (in macroblocks)
	int MAXH_IN_MB = 69;

	int BUF_SZ = MAXW_IN_MB * (384 * MAXH_IN_MB + SEARCHWIN_IN_MB * 192 + 384);

	int FLAG_SZ = 4;

	int PIX_SZ = 9;

	/////////////////////////////////////////////////////////////////////////////
	// buffer
	List(type: int(size=PIX_SZ), size=BUF_SZ) buf := [ 0 : for int i in 1 .. BUF_SZ ];

	/////////////////////////////////////////////////////////////////////////////
	// interpolation
	int(size=3) flags;

	int(size=2) round;

	// compensation function
	function compensate(int p00, int p10, int p01, int p11) --> int :
		if flags = 0 then
			p00
		else
			if flags = 1 then
			// interpolate y only
				((p00 + p01 + 1) - round) >> 1
			else
				if flags = 2 then
				// interpolate x only
					((p00 + p10 + 1) - round) >> 1
				else
				// interpolate x and y
					((p00 + p10 + p01 + p11 + 2) - round) >> 2
				end
			end
		end
	end

	/////////////////////////////////////////////////////////////////////////////
	// Ignore new VOP command
	cmd.newVop: action BTYPE:[ cmd ] ==>
	guard
		(cmd & NEWVOP) != 0
	end

	// Pure texture
	cmd.textureOnly: action BTYPE:[ cmd ] ==>
	guard
		(cmd & INTRA) != 0
	end

	// Pure motion
	cmd.motionOnly: action BTYPE:[ cmd ] ==>
	guard
		(cmd & ACCODED) = 0
	end

	// Mixed texture and motion
	// (Also used to skip vop w,h)
	cmd.other: action BTYPE:[ cmd ] ==>
	end

	texture: action TEX:[ tex ] repeat 64, WA:[ a ] repeat 64 ==> VID:[ tex ] repeat 64
	do
		foreach int i in 0 .. 63 do
			buf[a[i]] := tex[i];
		end
	end

	// compensation action
	motion: action halfpel:[ f ], RA:[ d ] repeat 81, WA:[ a ] repeat 64 ==> VID:[ mot ] repeat 64
	var
		List(type: int, size=64) mot := [ 0 : for int n in 0 .. 63 ]
	do
		flags := (f >> 1);
		round := (f & 1);
		foreach int i in 0 .. 7 do
			foreach int j in 0 .. 7 do
				mot[8 * i + j] := compensate(buf[d[9 * i + j]], buf[d[9 * i + j + 1]], buf[d[9 * (i + 1) + j]], buf[d[9 * (
				i + 1) + j + 1]]);
			end
		end
		foreach int i in 0 .. 63 do
			buf[a[i]] := mot[i];
		end
	end

	combine: action halfpel:[ f ], RA:[ d ] repeat 81, WA:[ a ] repeat 64, TEX:[ tex ] repeat 64 ==> VID:
		[ vid ] repeat 64
	var
		int output , List(type: int, size=64) mot := [ 0 : for int n1 in 0 .. 63 ] ,
		List(type: int, size=64) vid := [ 0 : for int n2 in 0 .. 63 ]
	do
		flags := (f >> 1);
		round := (f & 1);
		foreach int i in 0 .. 7 do
			foreach int j in 0 .. 7 do
				mot[8 * i + j] := compensate(buf[d[9 * i + j]], buf[d[9 * i + j + 1]], buf[d[9 * (i + 1) + j]], buf[d[9 * (
				i + 1) + j + 1]]);
			end
		end
		foreach int i in 0 .. 63 do
			output := tex[i] + mot[i];
			vid[i] := if output < 0 then
				0
			else
				if output > 255 then
					255
				else
					output
				end
			end;
		end
		foreach int i in 0 .. 63 do
			buf[a[i]] := vid[i];
		end
	end

	schedule fsm cmd :
		cmd ( cmd.newVop ) --> skipw;
		cmd ( cmd.textureOnly ) --> texture;
		cmd ( cmd.motionOnly ) --> motion;
		cmd ( cmd.other ) --> combine;
		texture ( texture ) --> cmd;
		motion ( motion ) --> cmd;
		combine ( combine ) --> cmd;
		skipw ( cmd.other ) --> skiph;
		skiph ( cmd.other ) --> cmd;
	end

	priority
		cmd.newVop > cmd.textureOnly > cmd.motionOnly > cmd.other;
	end

end