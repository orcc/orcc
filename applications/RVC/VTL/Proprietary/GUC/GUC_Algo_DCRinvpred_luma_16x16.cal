// Algo_DCRinvpred_luma_16x16
//
// Created By:  David B. Parlour (dave.parlour@xilinx.com)
// Modified By: Andrew Kinane (kinanea@eeng.dcu.ie)
//         
// Copyright (c) 2004-2005 Xilinx Inc.
// All Rights Reserved
//
// Disclaimer:  THIS PROGRAM IS PROVIDED "AS IS" WITH NO WARRANTY 
//              WHATSOEVER AND XILINX SPECIFICALLY DISCLAIMS ANY 
//              IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR
//              A PARTICULAR PURPOSE, OR AGAINST INFRINGEMENT.
//
// Functionality:
// This module reconstructs the DC coefficient of the current 8x8 block based on the
// gradients between neighbouring block DC coefficients (see ISO/IEC 14496-2). This 
// module also forwards the decoded prediction direction to the inverse AC prediction
// (IAP) module and a pointer to the neighbouring block used for the prediction. Since
// inverse quantisation is necessary to reconstruct the DC coefficient, the decoded 
// quantisation parameter is forwarded to the inverse quantisation module.
//
// Input Ports:
// ============
// int(size=BTYPE_SZ) BTYPE
// This input token specifies the coding mode of the current 8x8 block. When executing, 
// the first 3 BTYPE tokens of a VOP relate to global parameters of the VOP. The first BTYPE 
// token indicates a new VOP, and the subsequent two BTYPE tokens indicate the width and the 
// height of the VOP in macroblocks respectively. All subsequent BTYPE tokens for the VOP 
// specify the coding mode of the current 8x8 block. For details on the structure of the
// BTYPE token, refer to ParseHeaders.cal
//
// int(size=MB_COORD_SZ+2) A
// The address of the 8x8 block neighbour to the left of the current 8x8 block.
//
// int(size=MB_COORD_SZ+2) B
// The address of the 8x8 block neighbour to the above left of the current 8x8 block.
//
// int(size=MB_COORD_SZ+2) C
// The address of the 8x8 block neighbour to the above of the current 8x8 block.
//
// int(size=SAMPLE_SZ) QFS_DC
// The decoded prediction of the current block DC coefficient
//
// Output Ports:
// =============
// int(size=SAMPLE_SZ) QF_DC
// The reconstructed DC coefficient of the current block.
//
// int(size=MB_COORD_SZ+2) PTR
// The address of the 8x8 block used for the prediction in the encoder.
//
// int(size=3) AC_PRED_DIR
// A flag to communicate the direction of prediction to the IAP block but also info
// about the scan mode of the block to the inverse scan block
// AC_PRED_DIR = -2 => NEWVOP flag
// AC_PRED_DIR = -1 => An uncoded block so skip inverse AC prediction
// AC_PRED_DIR =  0 => No inverse AC prediction but use zig zag inverse scan
// AC_PRED_DIR =  1 => Prediction form the left and use alternate vertical scan
// AC_PRED_DIR =  2 => Prediction form the top and use alternate horizontal scan
//
// bool SIGNED
// A flag to indicate to the IDCT module that the block is either INTER or INTRA.
// This is used when saturating the reconstructed pixels if necessary.
// 
// int(size=QUANT_SZ) QUANT
// This is the decoded value of the flag 'quantiser_scale' . See see ISO/IEC 14496-2.
//
// Modifications:
// * Re-named output port START to AC_PRED_DIR
// * Function dc_scaler() is now luminance specific. 
// * In advance action, indices adjust after every 4 components instead of 6 since now
//   dealing with 4 8x8 blocks rather than 6 8x8 blocks.

package Proprietary.GUC;

import std.util.BitOps.*;

actor GUC_Algo_DCRinvpred_luma_16x16 () bool NEW_VOP, int(size=16) WIDTH, bool AC_CODED, int(size=MB_COORD_SZ + 2) A, int(size=MB_COORD_SZ +
2) B, int(size=MB_COORD_SZ + 2) C, int(size=SAMPLE_SZ) QFS_DC, int(size=QUANT_SZ) QP, int (size=2)BTYPE, bool AC_PRED ==>
int(size=SAMPLE_SZ) QF_DC , int(size=MB_COORD_SZ + 2) PTR , int(size=3) AC_PRED_DIR , bool
SIGNED , int(size=QUANT_SZ) QUANT , int(size=QUANT_SZ) PREV_QUANT :

// Port size declaration

	int MB_COORD_SZ = 8;

	int SAMPLE_SZ = 13;

	int MAXW_IN_MB = 121;

	int QUANT_SZ = 6;

	int DCVAL = 128*8;

	
	// Use 3 address lines for component index to save address calculation effort
	// Also, location 0 is reserved for all uncoded blocks. This protocol must
	// be identical to the buffer addressing in DCR_addressing_16x16.cal and IAP_16x16.cal, 
	// since pointer values are passed on ports A, B, C.     
	int SCALER_SZ = 7;

	// Bitwidth needed for 'dc_scalar' - see ISO/IEC 14496-2
	int(size=QUANT_SZ) s_qp;

	// Decoded 'quantiser_scale' - see ISO/IEC 14496-2
	int(size=QUANT_SZ) s_prev_qp;

	// previous Decoded 'quantiser_scale'
	int(size=2) round;

	// Flag to indicate whether 'quantiser_scale' is even or odd
	int BUF_SIZE = (MAXW_IN_MB + 2) * 4;

	// Have 4 8x8 blocks per MB
	int ptr := 4;

	// Pointer to current 8x8 block on current row
	// using circular buffer addressing. Start at 4, since 0-3 are reserved.
	int(size=4) comp := 0;

	// 8x8 block component in macroblock index  // JWJ: increased size
	// Initialize to the dummy values needed for uncoded blocks (always mapped to index 0)
	List(type: int(size=SAMPLE_SZ), size=BUF_SIZE) dc_buf := [ DCVAL : for int k in 1 .. BUF_SIZE ];

	int(size=SAMPLE_SZ) dc_pred;

	// Decoded DC prediction value
	int(size=SCALER_SZ) scaler;

	// Decoded 'dc_scalar'
	bool is_signed;

	// Flag to indicate INTER or INTRA block
	int(size=SAMPLE_SZ) dc_val;

	// Reconstructed DC coefficient  
	List(type: int(size=QUANT_SZ), size=BUF_SIZE * 4) buf_qp := [ 0 : for int k in 1 .. BUF_SIZE * 4 ];

	int(size=MB_COORD_SZ) mbwidth := 0;

	// Macroblock width of current vop
	int cnt := 0;

	// Pointer to current 8x8 block
	// Check for NEWVOP flag
	// A -ve flag  means there is no data, so the inverse zigzag may flush its buffer
	start: action NEW_VOP:[newvop] ==> AC_PRED_DIR:[ -2 ]
	guard
		newvop
	do
		comp := 0;
		ptr := 4;
	end

	// Used to get Width BTYPE token
	getw: action WIDTH:[ w ] ==>
	do
		mbwidth := w;
	end

	// Check for an INTER block with coded AC coefficients
	read.inter_ac: action NEW_VOP:[newvop], AC_CODED:[ac_coded], AC_PRED:[ac_pred], QP:[ qp ], BTYPE:[btype] ==> AC_PRED_DIR:[ 0 ], PTR:[ 0 ], SIGNED:[ true ],
		QUANT:[ s_qp ], PREV_QUANT:[ s_prev_qp ]
	guard
		btype=1,
		ac_coded,
		not(newvop)
	do
		s_qp := qp;
		round := bitxor((s_qp & 1), 1);
		is_signed := true;
		s_prev_qp := s_qp;
		buf_qp[cnt] := s_qp;
	end

	// Any other block except INTRA
	read.other: action NEW_VOP:[newvop], AC_CODED:[ac_coded], AC_PRED:[ac_pred], QP:[ qp ], BTYPE:[btype] ==> AC_PRED_DIR:[ -1 ]
	guard
		not ac_coded,
		btype!=2,
		not(newvop)
	end

	// Function to return absolute value
	function abs(int x) --> int :
		if x < 0 then
			(-x)
		else
			x
		end
	end

	// Calculate DC scaler for INTRA blocks.
	// Note that this function is specific to luminance 8x8 blocks!!!
	function dc_scaler() --> int(size=SCALER_SZ) :
	// Y component
		if s_qp > 0 and s_qp < 5 then
			8
		else
			if s_qp > 4 and s_qp < 9 then
				2 * s_qp
			else
				if s_qp > 8 and s_qp < 25 then
					s_qp + 8
				else
					(2 * s_qp) - 16
				end
			end
		end
	end

	// Read an INTRA block
	read.intra: action NEW_VOP:[newvop], BTYPE:[btype], AC_CODED:[ac_coded], AC_PRED:[ac_pred], QP:[ qp ], A:[ a ], B:[ b ], C:[ c ] ==> PTR:[ if top then
			c
		else
			a
		end ], AC_PRED_DIR:[ s ], SIGNED:[ is_signed ], QUANT:[ s_qp ], PREV_QUANT:[ s_prev_qp ]
	guard
		 btype=2,
		not(newvop)
	var
		int(size=SAMPLE_SZ) dca = dc_buf[a] , int(size=SAMPLE_SZ) dcb = dc_buf[b] ,
		int(size=SAMPLE_SZ) dcc = dc_buf[c] , int(size=SAMPLE_SZ) horiz = abs(dcb - dcc) ,
		int(size=SAMPLE_SZ) vert = abs(dca - dcb) , bool top = vert < horiz , int(size=3) s 
	do
		s_qp := qp;
		s_prev_qp := qp;
		round := bitxor((s_qp & 1), 1);
		scaler := dc_scaler();
		// Retrieve 'dc_scalar'. See ISO/IEC 14496-2 Table 7-1.
		dc_pred := ((if top then
			dcc
		else
			dca
		end) + (scaler >> 1)) / scaler;
		// See ISO/IEC 14496-2 Section 7.4.3.2.
		s := if not ac_pred then
			0
		else
			if top then
				2
			else
				1
			end
		end;
		// Set 'ac_pred_dir'
		is_signed := scaler = 0;
		// Will never be true!
		if (s = 2) then
			if (comp = 0) or (comp = 1) then
				s_prev_qp := buf_qp[cnt + 2];
			else
				if (comp = 2) or (comp = 3) then
					s_prev_qp := buf_qp[cnt - 2];
				end
			end
		end
		if (s = 1) and (cnt >= 3) then
			if (comp = 0) or (comp = 2) then
				s_prev_qp := buf_qp[cnt - 3];
			else
				if (comp = 1) or (comp = 3) then
					s_prev_qp := buf_qp[cnt - 1];
				end
			end
		end
		buf_qp[cnt] := s_qp;
	end

	// Do inverse prediction and dequant on INTER block DC
	getdc.inter: action QFS_DC:[ dc ] ==>
	var
		int(size=SAMPLE_SZ) v = (s_qp * (lshift(abs(dc), 1) + 1)) - round // See ISO/IEC 14496-2 Section 7.4.4.2.1 (H.263).

	do
		dc_val := if dc = 0 then
			0
		else
			if not is_signed then
				dc
			else
				if dc < 0 then
					-v
				else
					v
				end
			end
		end;
	end

	// Do inverse prediction on INTRA block DC
	getdc.intra: action QFS_DC:[ dc ] ==>
	do
		dc_val := (dc + dc_pred) * scaler;
		// See ISO/IEC 14496-2 Section 7.4.3.2 and Section 7.4.4.1.1.

	end

	function saturate(int x) --> int
	var
		bool minus = x < -2048,
		bool plus = x > 2047 :
		if minus then
			-2048
		else
			if plus then
				2047
			else
				x
			end
		end
	end

	sat: action ==> QF_DC:[ dc ]
	var
		int(size=SAMPLE_SZ) dc = saturate(dc_val)
	do
		dc_buf[(ptr | comp)] := dc;
	end

	advance: action ==>
	do
		cnt := cnt + 1;
		if (cnt = mbwidth * 4) then
			cnt := 0;
		end
		comp := comp + 1;
		if comp = 4 then
			comp := 0;
			ptr := if ptr = 4 then
				BUF_SIZE - 4
			else
				ptr - 4
			end;
		end
	end

	schedule fsm read :
		read ( start ) --> getw;
		read ( read.inter_ac ) --> inter;
		read ( read.intra ) --> intra;
		read ( read.other ) --> advance;
		getw ( getw ) --> read;
		intra ( getdc.intra ) --> sat;
		inter ( getdc.inter ) --> sat;
		sat ( sat ) --> advance;
		advance ( advance ) --> read;
	end

	priority
		start > read.inter_ac > read.other > read.intra;
	end

end