package MPEG.MPEG4.part2.iDCT;

actor Algo_IDCT2D_ISOIEC_23002_1 () int(size=13) IN, bool
SIGNED ==> int(size=9) OUT :

	int A = 1024;

	int B = 1138;

	int C = 1730;

	int D = 1609;

	int E = 1264;

	int F = 1922;

	int G = 1788;

	int H = 2923;

	int I = 2718;

	int J = 2528;

	List(type: int, size=64) scale = [ A, B, C, D, A, D, C, B, B, E, F, G, B, G,
	F, E, C, F, H, I, C, I, H, F, D, G, I, J, D, J, I, G, A, B, C, D, A, D, C, B,
	D, G, I, J, D, J, I, G, C, F, H, I, C, I, H, F, B, E, F, G, B, G, F, E ];

	intra: action IN:[ x ] repeat 64, SIGNED:[ s ] ==> OUT:[ block1 ] repeat 64
	var
		List(type: int, size=64) block1 , List(type: int, size=64) block2
	do
	// multiplier-based scaling
		block1 := [ scale[n] * x[n] : for int n in 0 .. 63 ];
		block1[0] := block1[0] + (1 << 12);
		// scaled 1D IDCT for rows and columns
		idct1d(block1, block2);
		idct1d(block2, block1);
		// downshifting
		block1 := [ (block1[n] >> 13) : for int n in 0 .. 63 ];
		// clipping
		block1 := [ clip(block1[n], 0) : for int n in 0 .. 63 ];
	end

	inter: action IN:[ x ] repeat 64, SIGNED:[ s ] ==> OUT:[ block1 ] repeat 64
	guard
		s
	var
		List(type: int, size=64) block1 , List(type: int, size=64) block2
	do
	// multiplier-based scaling
		block1 := [ scale[n] * x[n] : for int n in 0 .. 63 ];
		block1[0] := block1[0] + (1 << 12);
		// scaled 1D IDCT for rows and columns
		idct1d(block1, block2);
		idct1d(block2, block1);
		// downshifting
		block1 := [ (block1[n] >> 13) : for int n in 0 .. 63 ];
		// clipping
		block1 := [ clip(block1[n], -255) : for int n in 0 .. 63 ];
	end

	procedure idct1d(List(type: int, size=64) X, List(type: int, size=64) Y)
	var
		int temp1,
		int temp2,
		int temp3,
		int temp4,
		int xa,
		int xb
	begin
		foreach int i in 0 .. 7 do
			xa := X[8 * i + 1] + X[8 * i + 7];
			xb := X[8 * i + 1] - X[8 * i + 7];
			X[8 * i + 1] := xa + X[8 * i + 3];
			X[8 * i + 3] := xa - X[8 * i + 3];
			X[8 * i + 7] := xb + X[8 * i + 5];
			X[8 * i + 5] := xb - X[8 * i + 5];
			temp1 := pmul_1_1(X[8 * i + 3]);
			temp4 := pmul_1_2(X[8 * i + 3]);
			temp3 := pmul_1_1(X[8 * i + 5]);
			temp2 := pmul_1_2(X[8 * i + 5]);
			X[8 * i + 3] := temp1 - temp2;
			X[8 * i + 5] := temp3 + temp4;
			temp1 := pmul_2_1(X[8 * i + 1]);
			temp4 := pmul_2_2(X[8 * i + 1]);
			temp3 := pmul_2_1(X[8 * i + 7]);
			temp2 := pmul_2_2(X[8 * i + 7]);
			X[8 * i + 1] := temp1 + temp2;
			X[8 * i + 7] := temp3 - temp4;
			temp1 := pmul_3_1(X[8 * i + 2]);
			temp4 := pmul_3_2(X[8 * i + 2]);
			temp3 := pmul_3_1(X[8 * i + 6]);
			temp2 := pmul_3_2(X[8 * i + 6]);
			X[8 * i + 2] := temp1 - temp2;
			X[8 * i + 6] := temp3 + temp4;
			xa := X[8 * i + 0] + X[8 * i + 4];
			xb := X[8 * i + 0] - X[8 * i + 4];
			X[8 * i + 0] := xa + X[8 * i + 6];
			X[8 * i + 6] := xa - X[8 * i + 6];
			X[8 * i + 4] := xb + X[8 * i + 2];
			X[8 * i + 2] := xb - X[8 * i + 2];
			Y[i + 8 * 0] := X[8 * i + 0] + X[8 * i + 1];
			Y[i + 8 * 1] := X[8 * i + 4] + X[8 * i + 5];
			Y[i + 8 * 2] := X[8 * i + 2] + X[8 * i + 3];
			Y[i + 8 * 3] := X[8 * i + 6] + X[8 * i + 7];
			Y[i + 8 * 4] := X[8 * i + 6] - X[8 * i + 7];
			Y[i + 8 * 5] := X[8 * i + 2] - X[8 * i + 3];
			Y[i + 8 * 6] := X[8 * i + 4] - X[8 * i + 5];
			Y[i + 8 * 7] := X[8 * i + 0] - X[8 * i + 1];
		end
	end

	function pmul_1_1(int X) --> int
	var
		int Temp1 = (X >> 3) - (X >> 7) :
		X - Temp1
	end

	function pmul_1_2(int X) --> int
	var
		int Temp1 = (X >> 3) - (X >> 7),
		int Temp2 = Temp1 - (X >> 11) :
		Temp1 + (Temp2 >> 1)
	end

	function pmul_2_1(int X) --> int
	var
		int Temp1 = (X >> 9) - X :
		(Temp1 >> 2) - Temp1
	end

	function pmul_2_2(int X) --> int :
		(X >> 1)
	end

	function pmul_3_1(int X) --> int
	var
		int Temp1 = X + (X >> 5),
		int Temp2 = (Temp1 >> 2) :
		Temp2 + (X >> 4)
	end

	function pmul_3_2(int X) --> int
	var
		int Temp1 = X + (X >> 5),
		int Temp2 = (Temp1 >> 2) :
		Temp1 - Temp2
	end

	function clip(int x, int lim) --> int :
		if x < lim then
			lim
		else
			if x > 255 then
				255
			else
				x
			end
		end
	end

	priority
		inter > intra;
	end
end