/********************************************************************************

This software module was originally developed by 
Florian Decologne (IETR/INSA of Rennes), 
in the course of development of the ISO/IEC 23002-4 (Video Tool Library) 
for reference purposes and its performance may not have been optimized. 
This software module is an implementation of one or more tools as 
specified by the ISO/IEC 23002-4.

ISO/IEC gives You a royalty-free, worldwide, non-exclusive, copyright 
license to copy, distribute, and make derivative works of this software 
module or modifications thereof for use in implementations of the 
ISO/IEC 23002-4 in products that satisfy conformance criteria (if any). 

Those intending to use this software module in products are advised that 
its use may infringe existing patents. ISO/IEC have no liability for use 
of this software module or modifications thereof.

Copyright is not released for products that do not conform to audiovisual 
and image-coding related ITU Recommendations and/or ISO/IEC International 
Standards. 

Assurance that the originally developed software module can be used 
(1) in the ISO/IEC 23002-4 once the ISO/IEC 23002-4 has been adopted; and 
(2) to develop the ISO/IEC 23002-4: 

IETR/INSA of Rennes grants ISO/IEC all rights necessary to 
include the originally developed software module or modifications thereof 
in the ISO/IEC 23002-4 and to permit ISO/IEC to offer You a royalty-free, 
worldwide, non-exclusive, copyright license to copy, distribute, and make 
derivative works for use in implementations of the ISO/IEC 23002-4 in 
products that satisfy conformance criteria (if any), and to the extent 
that such originally developed software module or portions of it are 
included in the ISO/IEC 23002-4.  To the extent that IETR/INSA of Rennes
owns patent rights that would be required to make, use, or 
sell the originally developed software module or portions thereof 
included in the ISO/IEC 23002-4 in a conforming product, IETR/INSA of
Rennes will assure the ISO/IEC that it is willing to 
negotiate licenses under reasonable and non-discriminatory terms and 
conditions with applicants throughout the world.

ISO/IEC gives You a free license to this software module or modifications 
thereof for the sole  purpose of developing theISO/IEC 23002-4

IETR/INSA of Rennes retains full right to modify and use the 
code for its own purpose, assign or donate the code to a third party and 
to inhibit third parties from using the code for products that do not 
conform to MPEG-related ITU Recommendations and/or ISO/IEC International 
Standards. 

This copyright notice must be included in all copies or derivative works. 
Copyright (c) ISO/IEC 2008.

*****************************************************************************/
//Modified to work with ORCC
//By Endri Bezati <endri.bezati@insa-rennes.fr> IETR/INSA of Rennes
//Chnage


package MPEG.MPEG4.part10;
import std.util.BitOps.*;

actor Algo_Interp_split_MB_C () 
		uint(size=3) MbPartIdx, 
		uint(size=5) MbPartWidth, 
		uint(size=5) MbPartHeigth, 
		uint(size=8) INTERP 
				==> int(size=9) MBPred :
 
  uint(size=5) count := 0;
  uint(size=5) mbpart_idx;
  uint(size=5) mbpart_w;
  uint(size=5) mbpart_h;
  
  List ( type:int(size=16), size=64) MB := [ 0 : for int i in 0 .. 63];
  List ( type: uint(size=4), size=16) InverseScan4x4Tab := [ 0, 1, 4, 5, 2, 3, 6, 7, 8, 9, 12, 13, 10, 11, 14, 15 ];  
  
  get_part: action MbPartIdx:[a], MbPartWidth:[b], MbPartHeigth:[c] ==> 
  guard
    count < 16
  do
    mbpart_idx:= a;
    mbpart_w:= b/2;
    mbpart_h:= c/2;
  end
  
  get_data.mode8x8: action INTERP:[ v ] repeat 8*8 ==>
  guard
  	mbpart_w = 8 and mbpart_h = 8
  var 
    uint pixAddr := (InverseScan4x4Tab[count] /4 << 4) + (InverseScan4x4Tab[count] mod 4 << 1)
  do
  	foreach int j in 0 .. mbpart_h-1 do
      foreach int i in 0 .. mbpart_w-1 do
        MB[pixAddr+i+(j<<3)] := v[i+j*mbpart_w];
      end
    end
  	count := count + ( (mbpart_w>>1) * (mbpart_h>>1) );
  end
  
  get_data.mode8x4: action INTERP:[ v ] repeat 8*4 ==>
  guard
  	mbpart_w = 8 and mbpart_h = 4
  var 
    uint pixAddr := (InverseScan4x4Tab[count] /4 << 4) + (InverseScan4x4Tab[count] mod 4 << 1)
  do
  	foreach int j in 0 .. mbpart_h-1 do
      foreach int i in 0 .. mbpart_w-1 do
        MB[pixAddr+i+(j<<3)] := v[i+j*mbpart_w];
      end
    end
  	count := count + ( (mbpart_w>>1) * (mbpart_h>>1) );
  end
  
  get_data.mode4x8: action INTERP:[ v ] repeat 4*8 ==>
  guard
  	mbpart_w = 4 and mbpart_h = 8
  var 
    uint pixAddr := (InverseScan4x4Tab[count] /4 << 4) + (InverseScan4x4Tab[count] mod 4 << 1)
  do
  	foreach int j in 0 .. mbpart_h-1 do
      foreach int i in 0 .. mbpart_w-1 do
        MB[pixAddr+i+(j << 3)] := v[i+j*mbpart_w];
      end
    end
    
  	if ( mbpart_idx = 0 ) then
  		count := 4;
  	else
  		count := 16;
  	end
  end
  
  get_data.mode4x4: action INTERP:[ v ] repeat 4*4 ==>
  guard
  	mbpart_w = 4 and mbpart_h = 4
  var 
    uint pixAddr := (InverseScan4x4Tab[count] /4 << 4) + (InverseScan4x4Tab[count] mod 4 << 1)
  do
  	foreach int j in 0 .. mbpart_h-1 do
      foreach int i in 0 .. mbpart_w-1 do
        MB[pixAddr+i+(j<<3)] := v[i+j*mbpart_w];
      end
    end
    
  	count := count + ( (mbpart_w>>1) * (mbpart_h>>1) );
  end
  
  
  get_data.mode4x2: action INTERP:[ v ] repeat 4*2 ==>
  guard
  	mbpart_w = 4 and mbpart_h = 2
  var 
    uint pixAddr := (InverseScan4x4Tab[count] /4 << 4) + (InverseScan4x4Tab[count] mod 4 << 1)
  do
  	foreach int j in 0 .. mbpart_h-1 do
      foreach int i in 0 .. mbpart_w-1 do
        MB[pixAddr+i+(j<<3)] := v[i+j*mbpart_w];
      end
    end
  	count := count + ( (mbpart_w>>1) * (mbpart_h>>1) );
  end
  
  get_data.mode2x4: action INTERP:[ v ] repeat 2*4 ==>
  guard
  	mbpart_w = 2 and mbpart_h = 4
  var 
    uint pixAddr := lshift(InverseScan4x4Tab[count] /4, 4) + lshift(InverseScan4x4Tab[count] mod 4, 1)
  do
  	foreach int j in 0 .. mbpart_h-1 do
      foreach int i in 0 .. mbpart_w-1 do
        MB[pixAddr+i+(j<<3)] := v[i+j*mbpart_w];
      end
    end
  	count := count + 1 + (mbpart_idx<<1);
  end
  
  get_data.mode2x2: action INTERP:[ v ] repeat 2*2 ==>
  guard
  	mbpart_w = 2 and mbpart_h = 2
  var 
    uint pixAddr := (InverseScan4x4Tab[count] /4 << 4) + (InverseScan4x4Tab[count] mod 4 << 1)
  do
  	foreach int j in 0 .. mbpart_h-1 do
      foreach int i in 0 .. mbpart_w-1 do
        MB[pixAddr+i+(j<<3)] := v[i+j*mbpart_w];
      end
    end
  	count := count + ( (mbpart_w>>1) * (mbpart_h>>1) );
  end
  
  send_data: action ==> MBPred:[ [MB[s]: for int s in 0 .. 63] ] repeat 64
  guard
    count = 16
  do
    count := 0;
  end
  
  schedule fsm get_send_part :
    get_send_part	( get_part 	) --> get_data;
    get_data    	( get_data  ) --> get_send_part;
    get_send_part	( send_data	) --> get_send_part;
  end

end