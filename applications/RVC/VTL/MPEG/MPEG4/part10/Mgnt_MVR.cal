/********************************************************************************

This software module was originally developed by 
Florian Decologne (IETR/INSA of Rennes), 
in the course of development of the ISO/IEC 23002-4 (Video Tool Library) 
for reference purposes and its performance may not have been optimized. 
This software module is an implementation of one or more tools as 
specified by the ISO/IEC 23002-4.

ISO/IEC gives You a royalty-free, worldwide, non-exclusive, copyright 
license to copy, distribute, and make derivative works of this software 
module or modifications thereof for use in implementations of the 
ISO/IEC 23002-4 in products that satisfy conformance criteria (if any). 

Those intending to use this software module in products are advised that 
its use may infringe existing patents. ISO/IEC have no liability for use 
of this software module or modifications thereof.

Copyright is not released for products that do not conform to audiovisual 
and image-coding related ITU Recommendations and/or ISO/IEC International 
Standards. 

Assurance that the originally developed software module can be used 
(1) in the ISO/IEC 23002-4 once the ISO/IEC 23002-4 has been adopted; and 
(2) to develop the ISO/IEC 23002-4: 

IETR/INSA of Rennes grants ISO/IEC all rights necessary to 
include the originally developed software module or modifications thereof 
in the ISO/IEC 23002-4 and to permit ISO/IEC to offer You a royalty-free, 
worldwide, non-exclusive, copyright license to copy, distribute, and make 
derivative works for use in implementations of the ISO/IEC 23002-4 in 
products that satisfy conformance criteria (if any), and to the extent 
that such originally developed software module or portions of it are 
included in the ISO/IEC 23002-4.  To the extent that IETR/INSA of Rennes
owns patent rights that would be required to make, use, or 
sell the originally developed software module or portions thereof 
included in the ISO/IEC 23002-4 in a conforming product, IETR/INSA of
Rennes will assure the ISO/IEC that it is willing to 
negotiate licenses under reasonable and non-discriminatory terms and 
conditions with applicants throughout the world.

ISO/IEC gives You a free license to this software module or modifications 
thereof for the sole  purpose of developing theISO/IEC 23002-4

IETR/INSA of Rennes retains full right to modify and use the 
code for its own purpose, assign or donate the code to a third party and 
to inhibit third parties from using the code for products that do not 
conform to MPEG-related ITU Recommendations and/or ISO/IEC International 
Standards. 

This copyright notice must be included in all copies or derivative works. 
Copyright (c) ISO/IEC 2008.
*****************************************************************************/
package MPEG.MPEG4.part10;
import std.util.BitOps.*;

actor Mgnt_MVR () 
	uint(size=3) MbPartIdx,
	uint(size=4) RefIdx,
	uint(size=5) MbPartWidth,
	uint(size=5) MbPartHeigth,
	uint(size=13) CurrMbAddr,
	uint(size=13) FirstMbInSlice,
	uint(size=7) PicWidthInMb,
	int(size=16) MV,
	uint(size=1) MbIntraFlag
		==> 
		uint(size=11)Location, 
		uint(size=6) PartSZ, 
		uint(size=3) refIdxLXN, 
		int(size=16) mvLX,
		int(size=16) mv_out,
		uint(size=4) refidx_out
		:

	//FIXME! number of MB per line of picture
	int PICWIDTH=1280/16; //number of MB per lines
	int PICHEIGHT=720/16; //number of MB per columns
 
	    
	uint(size=5) count := 16;
	uint(size=13) currmb:= 0;
	uint(size=13) first_mb_in_slice:= 0;
	uint x:= 0;
	uint y:= 0;
	uint picW;
	uint(size=5) mbpart_idx;
	int(size=5) ref_idx;
	uint(size=5) mbpart_w;
	uint(size=5) mbpart_h;
	bool mvdone:=true;
  
	List(type: List(type:List(type:int(size=14), size=2), size=16), size=PICWIDTH*PICHEIGHT) mv:= [ [[0, 0] : for int i in 0 .. 15 ]: for int j in 0 .. PICWIDTH*PICHEIGHT-1 ];
	List(type: List(type:int(size=5), size=16), size=PICWIDTH*PICHEIGHT) refidx:=[[-2 : for int i in 0 .. 15]: for int j in 0 .. PICWIDTH*PICHEIGHT-1 ];
  
	List(type: uint(size=4), size=16) InverseScan4x4Tab := [ 0, 1, 4, 5, 2, 3, 6, 7, 8, 9, 12, 13, 10, 11, 14, 15 ];
  
  
	// initialize mv to a huge list of [0, 0]s, and refidx to a huge list of -2's  
	get_pos_intra: action CurrMbAddr: [a], PicWidthInMb: [b], MbIntraFlag:[c], FirstMbInSlice:[d] ==>
	guard
		count >= 16,
    	c !=0
  	do
  	    refidx[a]:=[-1 : for int i in 0 .. 15];
  	    mv[a] := [ [0, 0] : for int i in 0 .. 15];
	end
  
	get_pos_inter: action CurrMbAddr: [a], PicWidthInMb: [b], MbIntraFlag:[c], FirstMbInSlice:[d] ==>  
	guard
		count >= 16,
		c = 0
	do
		first_mb_in_slice:=d;
		picW := b; 
		currmb := a;
		x := a mod picW;
		y := a / picW;
		count := 0;
		mvdone:=false;
  	    refidx[a]:=[-2 : for int i in 0 .. 15];
	end
  
	get_part: action MbPartIdx:[a], RefIdx:[b], MbPartWidth:[c], MbPartHeigth:[d] ==> PartSZ:[c , d], Location:[locx , locy]
	guard
		count < 16
	var
		uint(size=11) locx, uint(size=11) locy
	do
		mbpart_idx:= a;
		ref_idx := b;
		mbpart_w:= c;
		mbpart_h:= d;
		locx := (x << 4) + ((InverseScan4x4Tab[count] mod 4) << 2);
		locy := (y << 4) + ((InverseScan4x4Tab[count] / 4) << 2);
	end
  
	send_part.others: action ==> refIdxLXN:[[refABC[t]:for int t in 0 .. 2]] repeat 3, mvLX:[[mvABC[s]:for int s in 0 .. 5]] repeat 6
	var 
		// uint CurrMb4x4Addr := y * (picW << 4) + (x << 2)+ (InverseScan4x4Tab[count] /4) * (picW << 2) + (InverseScan4x4Tab[count] mod 4),
		List(type:int(size=5),size=3) refABC := [-2 : for int i in 0 .. 2],
		uint(size=2) match_count := 0,
		List(type:int,size=6) mvABC := [0 : for int i0 in 0 .. 5]
	do
		if ((x=0 or currmb = first_mb_in_slice) and InverseScan4x4Tab[count] mod 4=0)=false then // MB 4x4 current situated on the first column of MBs 4x4, so there is no MB 4x4 at left  
			if (InverseScan4x4Tab[count] mod 4 =0) then
				refABC[0]:=refidx[currmb - 1][InverseScan4x4Tab[count] + 3];
				if refABC[0] != -2 then 
					mvABC[0] := mv[currmb - 1][InverseScan4x4Tab[count] + 3][0];
					mvABC[1] := mv[currmb - 1][InverseScan4x4Tab[count] + 3][1];
					if refABC[0] = ref_idx then 
						match_count := match_count +1;
					end
				end
			else
				refABC[0]:=refidx[currmb][InverseScan4x4Tab[count] - 1];
				if refABC[0] != -2 then 
					mvABC[0] := mv[currmb][InverseScan4x4Tab[count] - 1][0];
					mvABC[1] := mv[currmb][InverseScan4x4Tab[count] - 1][1];
					if refABC[0] = ref_idx then 
						match_count := match_count +1;
					end
				end
			end
		end
		if (currmb<picW+first_mb_in_slice and InverseScan4x4Tab[count]<4)=false then // MB 4x4 current situated on the first line of MBs 4x4, so there is no MB 4x4 above  
			if (InverseScan4x4Tab[count] < 4) then
				refABC[1]:=refidx[currmb - picW][InverseScan4x4Tab[count] + 12];
				if refABC[1] != -2 then 
					mvABC[2] := mv[currmb - picW][InverseScan4x4Tab[count] + 12][0];
					mvABC[3] := mv[currmb - picW][InverseScan4x4Tab[count] + 12][1];
					if refABC[1] = ref_idx then 
						match_count := match_count +1;
					end
				end
			else
				refABC[1]:=refidx[currmb][InverseScan4x4Tab[count] - 4];
				if refABC[1] != -2 then 
					mvABC[2] := mv[currmb][InverseScan4x4Tab[count] - 4][0];
					mvABC[3] := mv[currmb][InverseScan4x4Tab[count] - 4][1];
					if refABC[1] = ref_idx then 
						match_count := match_count +1;
					end
				end
			end
	    end
		if mbpart_w = 16 and mbpart_h = 16
		   and mbpart_idx = 1 
		   and (refABC[0] = -2 or refABC[1] = -2 or (refABC[0] = 0 
		   and mvABC[0] = 0 and mvABC[1] = 0) or (refABC[1] = 0 
		   and mvABC[2] = 0 and mvABC[3] = 0)) then
      		mvABC := [0 : for int t in 0 .. 5];
		else 
			if (( (currmb + ((InverseScan4x4Tab[count] mod 4 + (mbpart_w >> 2)) >> 2) <picW+first_mb_in_slice and InverseScan4x4Tab[count]<4 )
			    or x + ((InverseScan4x4Tab[count] mod 4 + (mbpart_w >> 2)) >> 2) = picW)
			    =false) then
				if(InverseScan4x4Tab[count] + (mbpart_w >> 2) < 4) then
					refABC[2]:= refidx[currmb - picW][InverseScan4x4Tab[count] + (mbpart_w >> 2) + 12];
					if refABC[2] != -2 then 
						mvABC[4] := mv[currmb - picW][InverseScan4x4Tab[count] + (mbpart_w >> 2) + 12][0];
						mvABC[5] := mv[currmb - picW][InverseScan4x4Tab[count] + (mbpart_w >> 2) + 12][1];
						if refABC[2] = ref_idx then 
							match_count := match_count +1;
						end
					end
				else
					if (InverseScan4x4Tab[count] + mbpart_w /4)=4 then
						refABC[2]:= refidx[currmb+1-picW][12];
						if refABC[2] != -2 then 
							mvABC[4] := mv[currmb+1-picW][12][0];
							mvABC[5] := mv[currmb+1-picW][12][1];
							if refABC[2] = ref_idx then 
								match_count := match_count +1;
							end
						end
					else
						if (InverseScan4x4Tab[count] mod 4 + (mbpart_w >> 2)=4) then
							refABC[2]:= -2;
						else
							refABC[2]:= refidx[currmb][InverseScan4x4Tab[count] + (mbpart_w >> 2) - 4];
							if refABC[2] != -2 then 
								mvABC[4] := mv[currmb][InverseScan4x4Tab[count] + (mbpart_w >> 2) - 4][0];
								mvABC[5] := mv[currmb][InverseScan4x4Tab[count] + (mbpart_w >> 2) - 4][1];
								if refABC[2] = ref_idx then 
									match_count := match_count +1;
								end
							end
						end
					end
				end
			end
			//TODO
			if refABC[2] = -2 
			   and ((x=0 or currmb  = first_mb_in_slice) and InverseScan4x4Tab[count] mod 4=0)=false 
			   and (currmb<=picW+first_mb_in_slice and InverseScan4x4Tab[count] < 4)=false then 
				if (InverseScan4x4Tab[count] =0 and currmb >= first_mb_in_slice + picW + 1) then
					refABC[2]:=refidx[currmb - 1 - picW][15];
					if refABC[2] != -2 then 
						mvABC[4] := mv[currmb - 1 - picW][15][0];
						mvABC[5] := mv[currmb - 1 - picW][15][1];
						if refABC[2] = ref_idx then 
							match_count := match_count + 1;
						end
					end
				else
					if (InverseScan4x4Tab[count] < 4) then
						refABC[2]:=refidx[currmb - picW][InverseScan4x4Tab[count] + 12 - 1];
						if refABC[2] != -2 then 
							mvABC[4] := mv[currmb - picW][InverseScan4x4Tab[count] + 12 - 1][0];
							mvABC[5] := mv[currmb - picW][InverseScan4x4Tab[count] + 12 - 1][1];
							if refABC[2] = ref_idx then 
								match_count := match_count + 1;
							end
						end
					else 
						if (InverseScan4x4Tab[count] mod 4 = 0) then
							refABC[2]:=refidx[currmb - 1][InverseScan4x4Tab[count] - 1];
							if refABC[2] != -2 then 
								mvABC[4] := mv[currmb - 1][InverseScan4x4Tab[count] - 1][0];
								mvABC[5] := mv[currmb - 1][InverseScan4x4Tab[count] - 1][1];
								if refABC[2] = ref_idx then 
									match_count := match_count + 1;
								end
							end
						else
							refABC[2]:=refidx[currmb][InverseScan4x4Tab[count] - 1 - 4];
							if refABC[2] != -2 then 
								mvABC[4] := mv[currmb][InverseScan4x4Tab[count] - 1 - 4][0];
								mvABC[5] := mv[currmb][InverseScan4x4Tab[count] - 1 - 4][1];
								if refABC[2] = ref_idx then 
									match_count := match_count + 1;
								end
							end
						end
					end
				end
			end
			if match_count = 1 then 
				if refABC[0] = ref_idx then 
					mvABC[4] := mvABC[0]; 
					mvABC[5] := mvABC[1]; //mvC = mvA
				else 
					if refABC[1] = ref_idx then 
						mvABC[4] := mvABC[2];
						mvABC[5] := mvABC[3];  //mvC = mvB
					else
						mvABC[0] := mvABC[4];
						mvABC[1] := mvABC[5]; //mbA = mvC
					end 
				end
			else 
				if match_count = 0 then
					if refABC[0] != -2 and refABC[1] = -2 and refABC[2] = -2 then
						mvABC[4] := mvABC[0];
						mvABC[5] := mvABC[1];//mvC = mvA
					end
				end
			end
		end
	end
  
  get_mv.part4x8: action MV:[a,b] ==>
  guard
    mbpart_w = 4 and mbpart_h = 8 
  do
      mv[currmb][InverseScan4x4Tab[count]][0] := a;
      mv[currmb][InverseScan4x4Tab[count]][1] := b;
      refidx[currmb][InverseScan4x4Tab[count]]:=ref_idx;
      mv[currmb][InverseScan4x4Tab[count] + 4][0] := a;
      mv[currmb][InverseScan4x4Tab[count] + 4][1] := b;
      refidx[currmb][InverseScan4x4Tab[count] + 4] :=ref_idx;
      count := count+1+(mbpart_idx << 1);
  end
  
  get_mv.part8x16: action MV:[a,b] ==>
  guard
    mbpart_w = 8 and mbpart_h = 16  
  do
    foreach int i in 0 .. 3 do
      mv[currmb][InverseScan4x4Tab[count]] := [a,b];
      refidx[currmb][InverseScan4x4Tab[count]]:=ref_idx;
      mv[currmb][InverseScan4x4Tab[count] + 8] := [a,b];
      refidx[currmb][InverseScan4x4Tab[count] + 8]:=ref_idx;
      count := count+1;
    end
    if mbpart_idx = 1 then count :=16; end
  end
  
  get_mv.others: action MV:[a,b] ==> 
  do
    foreach int i in 0 .. (mbpart_w >> 2)*(mbpart_h >> 2)-1 do
      mv[currmb][InverseScan4x4Tab[count]] := [a,b];
      refidx[currmb][InverseScan4x4Tab[count]]:=ref_idx;
      count := count+1;
    end
  end
  
  a_mv_out: action  ==>  refidx_out:[[refidx_out_l[i0]:for int i0 in 0 .. 15]] repeat 16, mv_out:[[mv_out_l[s]:for int s in 0 .. 31]] repeat 32
  guard
    count >= 16 and  mvdone=false
  var 
    List(type:uint(size=5),size=16) refidx_out_l := [-2 : for int i2 in 0 .. 15],
    List(type:int(size=14),size=32) mv_out_l := [0 : for int i1 in 0 .. 31]   
  do    
    foreach int i in 0 .. 15 do
	    mv_out_l[2*i]:= mv[currmb][i][0];
	    mv_out_l[2*i+1]:= mv[currmb][i][1];
	end
    refidx_out_l := [refidx[currmb][i]: for int i in 0 .. 15];
    mvdone:=true;
  end
  
  
  schedule fsm get_pos :
    get_pos     ( get_pos_intra ) --> get_pos;
    get_pos     ( get_pos_inter ) --> get_part;
    get_part	( get_part 		) --> send_part;
    send_part   ( send_part 	) --> get_mv;
    get_mv		( get_mv 		) --> get_part;
    get_part    ( a_mv_out		) --> get_pos;
  end

  priority
	get_mv.part4x8 > get_mv.part8x16 > get_mv.others;
	a_mv_out>get_part;
  end
    
end