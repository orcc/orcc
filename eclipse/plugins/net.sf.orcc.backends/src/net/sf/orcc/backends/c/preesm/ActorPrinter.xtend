/*
 * Copyright (c) 2012, IETR/INSA of Rennes
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 *   * Redistributions of source code must retain the above copyright notice,
 *     this list of conditions and the following disclaimer.
 *   * Redistributions in binary form must reproduce the above copyright notice,
 *     this list of conditions and the following disclaimer in the documentation
 *     and/or other materials provided with the distribution.
 *   * Neither the name of the IETR/INSA of Rennes nor the names of its
 *     contributors may be used to endorse or promote products derived from this
 *     software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
 * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

package net.sf.orcc.backends.c.preesm

import java.io.File
import java.util.Map
import net.sf.orcc.backends.c.InstancePrinter
import net.sf.orcc.df.Action
import net.sf.orcc.ir.InstReturn
import net.sf.orcc.ir.Procedure
import net.sf.orcc.util.OrccUtil

/**
 * Generate network as graphml file
 * 
 * @author Antoine Lorence
 * @author Karol Desnos
 */
class ActorPrinter extends InstancePrinter {

	new(Map<String, Object> options) {
		super(options)
	}

	override print(String targetFolder) {
		var numFilesCached = 0

		val idlContent = actorIDLContent
		val idlFile = new File(targetFolder + File::separator + "Code" + File::separator
			+ "IDL" + File::separator + actor.simpleName + ".idl")

		if(needToWriteFile(idlContent, idlFile)) {
			OrccUtil::printFile(idlContent, idlFile)
		} else {
			numFilesCached = numFilesCached + 1
		}

		val cContent = actorCContent
		val cFile = new File(targetFolder + File::separator + "Code" + File::separator
			+ "src" + File::separator + actor.simpleName + ".c")

		if(needToWriteFile(cContent, cFile)) {
			OrccUtil::printFile(cContent, cFile)
		} else {
			numFilesCached = numFilesCached + 1
		}

		return numFilesCached
	}

	// Note : It might be a good idea to write net.sf.orcc.ir.util.IDLTypePrinter
	def private getActorIDLContent() '''
		module «actor.simpleName» {

			typedef long parameter;
			typedef char i8;
			typedef short i16;
			typedef long i32;
			typedef long long i64;

			typedef char u8;
			typedef unsigned short u16;
			typedef unsigned long u32;
			typedef unsigned long long u64;

			«IF ! actor.stateVars.empty»
				«printStateVarsStruct»
			«ENDIF»

			«IF ! actor.initializes.empty»
				«printInterface(actor.initializes.head, "init")»
			«ENDIF»
			«IF ! actor.actions.empty»
				«printInterface(actor.actions.head, "loop")»
			«ENDIF»
		};
	'''

	def private printInterface(Action action, String inter) '''
		interface «inter» {
			void «actor.simpleName»_«action.name» («action.printIDLParameters»);
		};
	'''

	def private getActorCContent() '''
		/**
		 Generated by the Orcc C Embedded backend
		 from actor "«actor.name»"
		*/

		#include <stdio.h>
		#include <stdlib.h>
		#include "orcc_types.h"

		«IF ! actor.procs.filter[! native].empty»
			«IF ! actor.stateVars.empty»
				////////////////////////////////////////////////////////////////////////////////
				// State variables structure
				«printStateVarsStruct»
			«ENDIF»

			////////////////////////////////////////////////////////////////////////////////
			// Functions / procedures
			«FOR procedure : actor.procs.filter[! native]»
				«procedure.returnType.doSwitch» «actor.simpleName»_«procedure.name»(«procedure.printParameters»);
			«ENDFOR»
			
			«FOR procedure : actor.procs.filter[! native]»
				«procedure.returnType.doSwitch» «actor.simpleName»_«procedure.name»(«procedure.printParameters») {
					«IF ! procedure.locals.empty»
						«FOR local : procedure.locals»
							«local.declare»;
						«ENDFOR» 
					«ENDIF»

					«IF ! actor.stateVars.empty»
						«FOR stateVar : actor.stateVars»
							«stateVar.type.doSwitch» «stateVar.name» = stateVars_o->«stateVar.name»;
						«ENDFOR»
					«ENDIF»

					«FOR block : procedure.blocks»
						«block.doSwitch»
					«ENDFOR»
				}

			«ENDFOR»
		«ENDIF»
		////////////////////////////////////////////////////////////////////////////////
		// Actions
		«FOR action : actor.actions»
			«action.print»
		«ENDFOR»

		«IF ! actor.initializes.empty»
			////////////////////////////////////////////////////////////////////////////////
			// Initializes 
			«/**! Not functional yet :
			 In SDF classification, the token production obtained for an actor with an
			 initialize action include the number of token produce by this initialize 
			 action. This is not correct as the token produced by the initialize action
			 are not produced during each execution of the actor, but only when the actor
			 is instantiated !*/»
			«FOR init : actor.initializes»
				«init.print»
			«ENDFOR»
		«ENDIF»
	'''

	def private printStateVarsStruct() '''
		struct StateVars {
			«FOR stateVar : actor.stateVars»
				«stateVar.type.doSwitch» «stateVar.name»;
			«ENDFOR»
		}
	'''

	def private printParameters(Action action) {
		var elements = actor.parameters.map['''«declare»''']
					 + action.inputPattern.ports.map['''«type.doSwitch» *«name»''']
					 + action.outputPattern.ports.map['''«type.doSwitch» *«name»''']
		if(!actor.stateVars.empty) {
			elements = elements + newArrayList("struct StateVars *stateVars_i", "struct StateVars *stateVars_o")
		}
		return elements.filter[ ! empty].join(", ")
	}

	def private printIDLParameters(Action action) {
		var elements = actor.parameters.map['''in parameter «name»''']
					 + action.inputPattern.ports.map['''in «type.doSwitch» «name»''']
					 + action.outputPattern.ports.map['''out «type.doSwitch» «name»''']
		if(!actor.stateVars.empty) {
			elements = elements + newArrayList("in struct StateVars *stateVars_i", "out struct StateVars *stateVars_o")
		}
		return elements.filter[ ! empty].join(", ")
	}

	def private printParameters(Procedure procedure) {
		// TODO: if(actor.params.get(i).port) : print '*' before «name»
		var elements = actor.parameters.map['''«type.doSwitch» «name»''']
					 + procedure.parameters.map['''«variable.declare»''']
		if(!actor.stateVars.empty) {
			elements = elements + newArrayList("struct StateVars *stateVars_o")
		}
		return elements.filter[ ! empty].join(", ")
	}

	override protected print(Action action) '''
		void «actor.simpleName»_«action.body.name»(«action.printParameters»)
		{
			«IF ! action.body.locals.empty»
				«FOR local : action.body.locals»
					«local.declare»;
				«ENDFOR»
			«ENDIF»
			«IF ! actor.stateVars.empty»
				// Initialize stateVars and work on them
				«FOR stateVar : actor.stateVars»
					«IF stateVar.type.dimensionsExpr.empty»
						«stateVar.declare» = stateVars_i->«stateVar.name»;
					«ELSE»
						«stateVar.type.doSwitch» *«stateVar.name» = stateVars_i->«stateVar.name»;
					«ENDIF»
				«ENDFOR»
			«ENDIF»

			«FOR block : action.body.blocks»
				«block.doSwitch»
			«ENDFOR»
		}
	'''

	override caseInstReturn(InstReturn ret) '''
		«IF ! actor.stateVars.empty»
			// Write state Var to output buf
			«FOR stateVar : actor.stateVars»
				«IF stateVar.type.dimensionsExpr.empty»
					stateVars_o->«stateVar.name» = «stateVar.name»;
				«ELSE»
					// Copy «stateVar.name» to output buffer
					memcpy(stateVars_o->«stateVar.name», «stateVar.name», «stateVar.type.dimensions.head»);
				«ENDIF»
			«ENDFOR» 
		«ENDIF»
		«IF ret.value != null»
			return «ret.value.doSwitch»;
		«ENDIF»
	'''
}