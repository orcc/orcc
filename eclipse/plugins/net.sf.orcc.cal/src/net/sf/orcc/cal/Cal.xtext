grammar net.sf.orcc.cal.Cal with org.eclipse.xtext.common.Terminals

import "http://www.eclipse.org/emf/2002/Ecore" as ecore

generate cal "http://orcc.sf.net/cal/Cal"

///////////////////////////////////////////////////////////////////////////////
// top-level entity
///////////////////////////////////////////////////////////////////////////////

AstEntity: 
	('package' package=QualifiedName ';')?
	(imports += Import)*
	
	( ((native ?= 'native')? 'actor' name=ID actor=AstActor)
	| ('unit' name=ID unit=AstUnit) );

Import: 'import' importedNamespace=QualifiedNameWithWildCard ';';

QualifiedName:
	ID ('.' ID)*;

QualifiedNameWithWildCard:
	QualifiedName '.*'?;
	
///////////////////////////////////////////////////////////////////////////////
// unit
///////////////////////////////////////////////////////////////////////////////

AstUnit: {AstUnit} ':'

	(functions += AstFunction
	| functions += AstNativeFunction
	| procedures += AstProcedure
	| procedures += AstNativeProcedure
	| variables += AstConstantVariable)*

	'end';

AstConstantVariable returns AstVariable:
	AstVariableDeclaration (constant ?= '=') value=AstExpression ';';

///////////////////////////////////////////////////////////////////////////////
// actor
///////////////////////////////////////////////////////////////////////////////

AstActor: {AstActor}
		'(' (parameters += AstParameter (',' parameters += AstParameter)*)? ')'
		(inputs += AstPort (',' inputs += AstPort)*)? '==>'
		(outputs += AstPort (',' outputs += AstPort)*)? ':'

	(functions += AstFunction
	| functions += AstNativeFunction
	| procedures += AstProcedure
	| procedures += AstNativeProcedure
	| actions += AstAction
	| initializes += AstInitialize
	| stateVariables += AstStateVariable)*

	('schedule' ('fsm' schedule=AstSchedule | 'regexp' scheduleRegExp=AstScheduleRegExp) 'end')?

	(priorities += AstPriority)*

	'end';

AstPort: (native ?= 'native')? type=AstType name=ID;

AstFunction:
	'function' name=ID
	'('
		(parameters += AstVariableDeclaration (',' parameters += AstVariableDeclaration)*)?
	')' '-->' type=AstType
	('var'
		variables += AstValuedVariableDeclaration
		(',' variables += AstValuedVariableDeclaration)*)? ':'
	(variables += AstValuedVariableDeclaration ';')*
	expression=AstExpression
	'end';

AstNativeFunction returns AstFunction:
	native?='native' 'function' name=ID
	'('
		(parameters += AstVariableDeclaration (',' parameters += AstVariableDeclaration)*)?
	')' '-->' type=AstType 'end';

AstProcedure:
	'procedure' name=ID
	'('
		(parameters += AstVariableDeclaration (',' parameters += AstVariableDeclaration)*)?
	')'
	('var'
		variables += AstValuedVariableDeclaration
		(',' variables += AstValuedVariableDeclaration)*)?
	'begin'
		(variables += AstValuedVariableDeclaration ';')*
		(statements += AstStatement)*
	'end';

AstNativeProcedure returns AstProcedure:
	native ?= 'native' 'procedure' name=ID
	'('
		(parameters += AstVariableDeclaration (',' parameters += AstVariableDeclaration)*)?
	')' 'end';

AstParameter returns AstVariable: AstVariableDeclaration ('=' value=AstExpression)?;

AstStateVariable returns AstVariable: AstValuedVariableDeclaration ';';

AstTag: (identifiers += ID) ('.' identifiers += ID)*;

///////////////////////////////////////////////////////////////////////////////
// priorities
///////////////////////////////////////////////////////////////////////////////

AstInequality:
	tags += AstTag ('>' tags += AstTag)+ ';';
	
AstPriority:
	{AstPriority}

	'priority'
		(inequalities += AstInequality)*
	'end';

///////////////////////////////////////////////////////////////////////////////
// schedule
///////////////////////////////////////////////////////////////////////////////

AstSchedule:
	initialState=[AstState] ':'
		(transitions += AstTransition)*;

AstTransition:
	source=[AstState] '(' tag=AstTag ')' '-->' target=[AstState] ';';

AstState: name=ID;

AstScheduleRegExp:
	AstRegExp;
	
AstRegExp:
	AstRegExpConcatenation({AstRegExpBinary.left=current} operator=('|') right=AstRegExpConcatenation)*;
AstRegExpConcatenation returns AstRegExp:
	AstRegExpPostfix({AstRegExpBinary.left=current} right=AstRegExpPostfix)*;
AstRegExpPostfix returns AstRegExp:
	AstRegExpGrouping({AstRegExpUnary.child=current} unaryOperator=('*'|'?'))*;
AstRegExpGrouping returns AstRegExp:
	  AstRegExpTerminal
	| '(' AstRegExp ')';

AstRegExpTerminal returns AstRegExp:
	{AstRegExpTag} tag=AstTag;

///////////////////////////////////////////////////////////////////////////////
// actions
///////////////////////////////////////////////////////////////////////////////

AstAction:
	{AstAction}

	(tag=AstTag ':')?
	'action'
	(inputs += AstInputPattern (',' inputs += AstInputPattern)*)?
	'==>'
	(outputs += AstOutputPattern (',' outputs += AstOutputPattern)*)?

	('guard' guards += AstExpression (',' guards += AstExpression)*)?
	('var'
		variables += AstValuedVariableDeclaration
		(',' variables += AstValuedVariableDeclaration)*)?
	('do'
		(variables += AstValuedVariableDeclaration ';')*
		(statements += AstStatement)*
	)?
	'end';

AstInitialize returns AstAction:
	{AstAction}

	(tag=AstTag ':')?
	'initialize'
	'==>'
	(outputs += AstOutputPattern (',' outputs += AstOutputPattern)*)?
	('guard' guards += AstExpression (',' guards += AstExpression)*)?
	('var'
		variables += AstValuedVariableDeclaration
		(',' variables += AstValuedVariableDeclaration)*)?
	('do'
		(variables += AstValuedVariableDeclaration ';')*
		(statements += AstStatement)*
	)?
	'end';

AstInputPattern: port=[AstPort] ':' '[' tokens+=AstToken (',' tokens+=AstToken)* ']'
	('repeat' repeat=AstExpression)?;

AstToken returns AstVariable: name=ID;

AstOutputPattern: port=[AstPort] ':' '[' values+=AstExpression (',' values+=AstExpression)* ']'
	('repeat' repeat=AstExpression)?;

///////////////////////////////////////////////////////////////////////////////
// statements
///////////////////////////////////////////////////////////////////////////////

AstStatementAssign:
	target=AstVariableReference
		('[' indexes += AstExpression ']')* ':=' value=AstExpression ';';

AstStatementCall:
	procedure=[AstProcedure|QualifiedName]
	'(' (parameters += AstExpression (',' parameters += AstExpression)*)? ')' ';';

AstStatementForeach:
	'foreach' variable=AstVariableDeclaration 'in' lower=AstExpression '..' higher=AstExpression
	'do'
		(statements += AstStatement)*
	'end';

AstStatementIf:
	'if' condition = AstExpression 'then'
		(then += AstStatement)*
	(elsifs += AstStatementElsif)*
	('else' (else += AstStatement)*)?
	'end';

AstStatementElsif:
	'elsif' condition = AstExpression 'then'
		(then += AstStatement)*;

AstStatementWhile:
	'while' condition=AstExpression 'do'
		(statements += AstStatement)*
	'end';

AstStatement:
	AstStatementAssign
	| AstStatementCall
	| AstStatementForeach
	| AstStatementIf
	| AstStatementWhile;

///////////////////////////////////////////////////////////////////////////////
// expressions
///////////////////////////////////////////////////////////////////////////////

AstExpression:
	AstExpressionAnd ({AstExpressionBinary.left=current} operator=('||' | 'or') right=AstExpressionAnd)*;
AstExpressionAnd returns AstExpression:
	AstExpressionBitor ({AstExpressionBinary.left=current} operator=('&&' | 'and') right=AstExpressionBitor)*;
AstExpressionBitor returns AstExpression:
	AstExpressionBitxor ({AstExpressionBinary.left=current} operator='|' right=AstExpressionBitxor)*;
AstExpressionBitxor returns AstExpression:
	AstExpressionBitand ({AstExpressionBinary.left=current} operator='^' right=AstExpressionBitand)*;
AstExpressionBitand returns AstExpression:
	AstExpressionEq ({AstExpressionBinary.left=current} operator='&' right=AstExpressionEq)*;
AstExpressionEq returns AstExpression:
	AstExpressionRelational ({AstExpressionBinary.left=current} operator=('=' | '!=') right=AstExpressionRelational)*;
AstExpressionRelational returns AstExpression:
	AstExpressionShift ({AstExpressionBinary.left=current} operator=('<' | '<=' | '>' | '>=') right=AstExpressionShift)*;
AstExpressionShift returns AstExpression:
	AstExpressionAdditive ({AstExpressionBinary.left=current} operator=('<<' | '>>') right=AstExpressionAdditive)*;
AstExpressionAdditive returns AstExpression:
	AstExpressionMultiplicative ({AstExpressionBinary.left=current} operator=('+' | '-') right=AstExpressionMultiplicative)*;
AstExpressionMultiplicative returns AstExpression:
	AstExpressionExp ({AstExpressionBinary.left=current} operator=('*' | '/' | 'div' | 'mod') right=AstExpressionExp)*;
AstExpressionExp returns AstExpression:
	AstExpressionUnary ({AstExpressionBinary.left=current} operator='**' right=AstExpressionUnary)*;

AstExpressionUnary returns AstExpression:
	{AstExpressionUnary} unaryOperator=('~' | '-' | 'not' | '#') expression=AstExpressionPostfix
	| AstExpressionPostfix;

AstExpressionPostfix returns AstExpression:
	AstExpressionList
	| AstExpressionCall
	| AstExpressionIndex
	| AstExpressionIf
    | AstExpressionLiteral
    | AstExpressionVariable
    | '(' AstExpression ')';

AstExpressionCall:
	function=[AstFunction|QualifiedName] '(' (parameters += AstExpression (',' parameters += AstExpression)*)? ')';

AstExpressionIndex:
	source=AstVariableReference ('[' indexes += AstExpression ']')+;

AstExpressionIf:
	'if' condition = AstExpression 'then'
		then = AstExpression
	(elsifs += AstExpressionElsif)*
	'else'
		else = AstExpression
	'end';

AstExpressionElsif:
	'elsif' condition = AstExpression 'then' then = AstExpression;

AstExpressionList:
	'[' expressions+=AstExpression (',' expressions+=AstExpression)*
	(':' generators+=AstGenerator (',' generators+=AstGenerator)*)? ']';

AstGenerator:
	'for' variable=AstVariableDeclaration 'in' lower=AstExpression '..' higher=AstExpression;

AstExpressionVariable: value=AstVariableReference;

///////////////////////////////////////////////////////////////////////////////
// literal expressions
///////////////////////////////////////////////////////////////////////////////

AstExpressionLiteral:
	AstExpressionBoolean
	| AstExpressionFloat
	| AstExpressionInteger
	| AstExpressionString;

AstExpressionBoolean: value=BOOL;

BOOL returns ecore::EBoolean: 'true' | 'false';

AstExpressionFloat: value=REAL;

terminal REAL returns ecore::EFloat :
	'-'? ('0'..'9')+ '.' ('0'..'9')* (('e'|'E') ('+' | '-')? ('0'..'9')+)?
|	'-'? '.' ('0'..'9')+ (('e'|'E') ('+' | '-')? ('0'..'9')+)?
|	'-'? ('0'..'9')+ ('e'|'E') ('+' | '-')? ('0'..'9')+;

AstExpressionInteger: value=(DECIMAL | OCTAL | HEX);

terminal DECIMAL returns ecore::ELong : '-'? ('1'..'9') ('0'..'9')*;

terminal OCTAL returns ecore::ELong : '0' ('0'..'7')*;

terminal HEX returns ecore::ELong : '0' ('x'|'X') ('0'..'9' | 'a'..'f' | 'A'..'F')+ ;

AstExpressionString: value=STRING;

///////////////////////////////////////////////////////////////////////////////
// common stuff
///////////////////////////////////////////////////////////////////////////////

AstType: AstTypeBool | AstTypeFloat | AstTypeInt | AstTypeList | AstTypeString | AstTypeUint;

AstTypeBool: {AstTypeBool} 'bool';

AstTypeFloat: {AstTypeFloat} 'float';

AstTypeInt: {AstTypeInt} 'int' ('(' 'size' '=' size = AstExpression ')')?;

AstTypeList: 'List' '(' 'type' ':' type = AstType ',' 'size' '=' size = AstExpression ')';

AstTypeString: {AstTypeString} 'String';

AstTypeUint: {AstTypeUint} 'uint' ('(' 'size' '=' size = AstExpression ')')?;

AstVariableDeclaration returns AstVariable: type=AstType name=ID
	('[' dimensions += AstExpression ']')*;

AstValuedVariableDeclaration returns AstVariable:
	AstVariableDeclaration ((constant ?= '=' | ':=') value=AstExpression)?;

AstVariableReference: variable=[AstVariable|QualifiedName];
